\documentclass[14pt]{book}
\include{TFformat}
\usepackage{multirow}
\usepackage{booktabs}
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\courseName}{\emph{Spectrum~Sensing~System
}} 
% Insert course name here
\title{\courseName}

% Headers and footers. See documentation for 'fancyhdr' package for more information.
\lhead{\scriptsize\fontfamily{lmr}\courseName} % Left header
% Center header
\rhead{\thepage} % Right header
\lfoot{} % Left footer
\cfoot{\scriptsize\fontfamily{lmr} Electronics and Computing, UNAL, Manizales} % Center footer
\rfoot{} % Right footer
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\providecommand{\H}{\texttt{HackRF~One}}
 
\usepackage{svg} 
\begin{document}
\maketitle
\thispagestyle{fancy}

\section*{High-Level Tasks in Cognitive Radio and Spectrum Sensing}

\begin{enumerate}
	\item \textbf{Power Spectral Density (PSD) Estimation.} This task involves estimating the distribution of power across different frequency components of a signal. It is fundamental to understanding the spectral characteristics of the observed environment.
	
	\begin{enumerate}
		\item \textit{PSD Estimation.}
		
		\item \textit{Quantitative Reconstruction of PSD.} This involves reconstructing the original PSD from noisy or undersampled data using techniques such as interpolation, smoothing, or model-based estimation.
		
		\item \textit{Spectral Parameter Estimation.} Key features derived from the PSD include:
		\begin{itemize}
			\item Peak frequencies (locations of maximum power),
			\item Bandwidth (range of occupied frequencies),
			\item Power levels at specific frequencies,
			\item Center frequency (mean spectral centroid).
		\end{itemize}
		
		\item \textit{Demodulation Support.} PSD estimation assists in identifying carrier frequencies and modulation schemes, facilitating demodulation of the received signals.
	\end{enumerate}
	
	\item \textbf{Signal Detection.} This task focuses on determining the presence of informative content within the received signal.
	
	\begin{enumerate}
		\item \textit{Detection of Signal Presence (Thresholding).} A threshold is applied to a test statistic (e.g., energy) to decide whether a signal is present.
		
		\item \textit{Symbol Detection.} Once signal presence is confirmed, the next step is identifying the transmitted symbols, such as bits in digital communication systems.
	\end{enumerate}
	
	\item \textbf{Identification and Classification of Signals.} This task involves characterizing signals based on observed features.
	
	\begin{enumerate}
		\item \textit{Modulation Classification.} Determining the modulation format (e.g., AM, FM, QAM, PSK) is critical for enabling correct demodulation and decoding.
		
		\item \textit{Spatio-Temporal Identification of Spurious Signals.} This involves localizing and characterizing unwanted signals across both spatial and temporal domains.
		
		\item \textit{Spatio-Temporal Identification of Interference.} Identifying and profiling interference sources that affect the desired signal, considering their spatio-temporal evolution.
	\end{enumerate}
	
	\item \textbf{Channel State Estimation.} Characterizing the wireless channel is essential for compensating for impairments such as fading or noise.
	
	\begin{enumerate}
		\item \textit{Channel Impulse Response (CIR).} Estimation of how the channel distorts the temporal profile of the signal.
		
		\item \textit{Channel Frequency Response (CFR).} Estimation of the channelâ€™s effect on signal amplitude and phase across frequency.
	\end{enumerate}
	
	\item \textbf{Decision-Making.} Based on the outcomes of the previous steps, appropriate decisions are made to complete the communication or control loop.
	
	\begin{enumerate}
		\item Decoding of the received data.
		\item Choosing an optimal action in adaptive or control-oriented systems.
		\item Interference identification and mitigation strategies.
	\end{enumerate}
\end{enumerate}


\clearpage\newpage

\begin{table}[h!]
	\centering
	\begin{tabular}{p{4.2cm}|p{1.5cm}|p{8cm}}
		\textbf{System} & \textbf{Year} & \textbf{Application Focus} \\
		\hline
		\texttt{GBSense} & 2024 & Wideband RF spectrum monitoring with low-cost setup. Utilizes sub-Nyquist sampling for real-time analysis. \\
		\hline
		\texttt{Compressed-Sensing Localization System} & 2024 & Real-time RF emitter detection and localization for non-cooperative civilian radio monitoring using compressed sensing. \\
	\end{tabular}
	\caption{Recent civilian-focused RF spectrum sensing systems developed since 2024.}
	\label{tab:spectrum_sensing_systems}
\end{table}

\subsection*{Implementation Details of \textit{GBSense}: A GHz-Bandwidth Compressed Spectrum Sensing System}

\subsubsection*{Core Architecture and Sampling Strategy}
\begin{itemize}
	\item \textbf{Periodic Non-Uniform Sampling via Time-Interleaved ADC (TI-ADC):} Utilizes multiple ADC lanes operating in parallel, interleaved in time, to form structured non-uniform sampling patterns. Enables capture of up to 2\,GHz of RF bandwidth with only 400\,MHz average sampling rate.
	\item \textbf{Clock Distribution and Synchronization:} A dedicated subsystem ensures precise timing across ADC channels, mitigating jitter and preserving temporal alignment.
\end{itemize}

\subsubsection*{Hardware Components}
\begin{itemize}
	\item \textbf{Power Splitter Subsystem:} Distributes incoming RF signals to multiple ADC lanes for parallel capture.
	\item \textbf{Time-Interleaved Sampling Subsystem:} Incorporates off-the-shelf ADC modules phased across time to support sub-Nyquist sampling.
	\item \textbf{Logic Device Subsystem:} FPGA or microcontroller-based logic handles sample alignment, decimation, buffering, and transmission to the host processor.
\end{itemize}

\subsubsection*{Real-Time Software Integration}
\begin{itemize}
	\item \textbf{Low-Power Processor:} A Raspberry Pi processes ADC output for spectral reconstruction using compressed sensing algorithms.
	\item \textbf{Software Pipeline:}
	\begin{enumerate}
		\item Data decimation and formatting,
		\item Compressed sensing-based spectrum reconstruction,
		\item Spectral detection via thresholding.
	\end{enumerate}
	\item \textbf{Latency:} Real-time spectrum sensing achieved with $\sim$30\,ms frame processing latency.
\end{itemize}

\subsubsection*{Performance Metrics}
\begin{itemize}
	\item \textbf{Detection Accuracy:}
	\begin{itemize}
		\item 100\% accuracy for spectrum occupancy below 100\,MHz,
		\item Over 80\% accuracy for 200\,MHz occupancy levels.
	\end{itemize}
	\item \textbf{Throughput:} Frame-wise analysis completed in under 30\,ms.
\end{itemize}

\subsubsection*{System Design Innovations}
\begin{itemize}
	\item \textbf{Hardware-Friendly Design:} Avoids analog delay lines typical in multicoset architectures; instead, uses programmable digital timing via TI-ADC.
	\item \textbf{Adaptive Sampling Pattern Control:} Sampling patterns are programmable, allowing adaptation to varying spectral environments.
	\item \textbf{Modular and Cost-Efficient:} Constructed with commercially available components and low-cost processing, suitable for scalable and field-deployable applications.
\end{itemize}

\subsubsection*{Summary of Key Specifications}
\begin{table}[h!]
	\centering
	\begin{tabular}{|l|l|}
		\hline
		\textbf{Feature} & \textbf{Specification} \\
		\hline
		RF Bandwidth & 2\,GHz \\
		Average Sampling Rate & 400\,MHz \\
		ADC Methodology & Time-Interleaved ADC (TI-ADC) \\
		Processor & Raspberry Pi \\
		Frame Processing Latency & $\sim$30\,ms \\
		Detection Accuracy @ <100\,MHz Occupancy & 100\% \\
		Detection Accuracy @ 200\,MHz Occupancy & >80\% \\
		\hline
	\end{tabular}
	\caption{Key technical characteristics of the GBSense system.}
	\label{tab:gbsense_specs}
\end{table}

\subsection*{Implementation Details of the Compressed-Sensing Localization System}

\subsection*{System Overview}
A prototype designed for \textit{real-time monitoring and localization of non-cooperative RF emitters}, using compressed sensing combined with TDoA (Time Difference of Arrival) measurements :contentReference[oaicite:1]{index=1}.

\subsubsection*{Hardware Architecture}
\begin{itemize}
	\item \textbf{Multiple Sensing Nodes:} Distributed SDR units capture wideband RF signals.
	\item \textbf{Compressed Sampling at Nodes:} Each node applies a measurement matrix (e.g., Gaussian) to compress incoming signals before transmission to a fusion center :contentReference[oaicite:2]{index=2}.
	\item \textbf{Fusion Node:} Collects compressed samples from nodes and performs joint reconstruction and localization.
\end{itemize}

\subsubsection*{Signal Processing Pipeline}
\begin{enumerate}
	\item \textbf{Compressed Sensing Reconstruction:} Implements greedy algorithms (e.g., OMP) or convex recovery to reconstruct wideband signals from under-sampled measurements :contentReference[oaicite:3]{index=3}.
	\item \textbf{TDoA Estimation:} Uses the reconstructed signals at multiple nodes to extract arrival-time differences for source localization :contentReference[oaicite:4]{index=4}.
	\item \textbf{Localization Algorithm:} Estimates emitter coordinates using TDoA multilateration based on reconstructed timing differences.
\end{enumerate}

\subsubsection*{Software and Computational Aspects}
\begin{itemize}
	\item \textbf{Localization Logic:} Fusion center runs CS recovery and TDoA multilateration algorithms in real time.
	\item \textbf{Mapping Interface:} Localization results are displayed on a digital/interactive map, even in offline settings :contentReference[oaicite:5]{index=5}.
\end{itemize}

\subsubsection*{Performance and Evaluation}
\begin{itemize}
	\item \textbf{Sample Compression Ratio:} Significant data reduction at nodes via CS before transmission.
	\item \textbf{Detection Performance:} ROC curves indicate that CS-enabled sensing achieves performance comparable to full-rate sampling even at moderate SNRs :contentReference[oaicite:6]{index=6}.
	\item \textbf{Localization Accuracy:} TDoA-based multilateration yields precise emitter positions; specific error metrics vary by node geometry and quality.
\end{itemize}

\subsubsection*{Innovations and Advantages}
\begin{itemize}
	\item \textbf{Efficient Use of Bandwidth:} Combines sub-Nyquist sampling and compressed sensing to reduce node-to-fusion bandwidth.
	\item \textbf{Scalable Architecture:} Easily extensible by adding SDR nodes to improve localization precision.
	\item \textbf{Real-Time Mapping:} Integration with digital map interfaces enables near real-time emitter tracking.
\end{itemize}

\subsubsection*{Key Specifications and Summary}
\begin{table}[h!]
	\centering
	\begin{tabular}{l|p{8cm}}
		\hline
		\textbf{Feature} & \textbf{Specification} \\
		\hline
		Number of Nodes & Multiple SDR-based sensing units \\
		Sampling Technique & Compressed sensing (e.g., using random Gaussian projections) \\
		Signal Recovery & Greedy (OMP) or convex CS algorithms \\
		Localization Method & TDoA multilateration on reconstructed signals \\
		Interface & Real-time display on digital/offline map \\
		Performance & ROC curves similar to full-rate systems at moderate SNR \\ 
		\hline
	\end{tabular}
	\caption{Technical summary of the compressed-sensing localization system.}
	\label{tab:cs_localization_specs}
\end{table}


\clearpage\newpage
\section*{ANE Spectrum Sensing System} 

\begin{figure}[!ht] 
	\centering
	\vspace*{1.2cm}
	\resizebox{\columnwidth}{!}{\input{Figures/GlobalScheme}}
		\caption{Global Diagram.}
\end{figure}
\clearpage\newpage
\paragraph*{Spectrum Sensing Specifications:}\,
\begin{figure}[!ht] 
	\centering
	\resizebox{\columnwidth}{!}{\includegraphics{Figures/MonitoreoMultiBanda.png}}
	\caption{Multiband Spectrum Sensing}
\end{figure}

\clearpage\newpage
\textit{Spectrum Sensing Networks:}
\begin{itemize}
	\item[\gc{RMER}] Red de monitoreo de Espectro Radiolectricoc 
	\item[\gc{RMTDT}] 	Red de monitoreo de TDT 
	\item[\gc{RCEM}] Red de Monitoreo de Campos Electromagneticos 
\end{itemize}
\medspace
\textit{Spectrum Sensing Bands and Services:} \gc{RMER} + \gc{ RMTDT}
\begin{table}[!ht]
	\centering
	\begin{tabular}{|l|l|l|l|l|}
		\hline
		\textbf{Band} & \textbf{Notation} & \textbf{Service} & \textbf{Subservice} & \textbf{Sub. Bandwidth} \\
		\hline
		% VHF entries
		\multirow{5}{*}{\centering VHF} & \textcolor{light-azul}{VHF 1} & RDS FM & Radio difusi\'on & 88MHz - 108MHz \\
		\cline{2-5}
		& \textcolor{light-azul}{VHF 2} & Fijo & Fijo y M\'ovil & 137MHz - 144MHz \\
		\cline{3-3}
		& & MÃ³vil & & \\
		\cline{2-5}
		& \textcolor{light-azul}{VHF 3} & Fijo & Fijo y M\'ovil & 148MHz - 174MHz \\
		\cline{3-3}
		& & M\'ovil & & \\
		\hline
		% UHF entries
		\multirow{5}{*}{\centering UHF} & \textcolor{light-azul}{UHF 1} & Fijo & Fijo y M\'ovil & 400MHz - 470MHz \\
		\cline{3-3}
		& & M\'ovil & & \\
		\cline{2-5}
		& \textcolor{light-azul}{UHF 2} & TDT & TV digital terrestre & 470MHz - 512MHz \\
		\cline{2-5}
		& \textcolor{light-azul}{UHF 3} & Banda L & Fijo y M\'ovil & 1GHz - 2GHz \\
		\hline		
		% SHF entries
		\multirow{2}{*}{\centering SHF} & \textcolor{light-azul}{SHF 1} & 5G & M\'ovil & 2555 MHz - 2560 MHz\\ 
		& & & & 2675 MHz - 2680 MHz \\
		\cline{2-2}
		& \textcolor{light-azul}{SHF 2} & & & 3300 MHz - 3620 MHz \\
		\hline
	\end{tabular}
	\caption{Tabla de bandas y servicios: \gc{RMER} + \gc{ RMTDT}}
\end{table}

\textit{Spectrum Sensing Bands and Services:} \gc{RMEM} 
\begin{table}[h!]
	\centering
	\begin{tabular}{|c|c|c|}
		\hline
		\textbf{Band} & \textbf{Notation} & \textbf{Bandwidth} \\ \hline
		\multirow{12}{*}{L Band} & \gc{L1} & 1427-1429 MHz \\ \cline{3-3} 
		& & 1429-1452 MHz \\ \cline{3-3} 
		& & 1452-1492 MHz \\ \cline{3-3} 
		& & 1492-1518 MHz \\ \cline{3-3} 
		& & 1518-1525 MHz \\ \cline{2-3}
		& \gc{L2} & 1660.5-1668 MHz \\ \cline{3-3} 
		& & 1700-1710 MHz \\ \cline{3-3} 
		& & 1710-1890 MHz \\ \cline{3-3} 
		& & 1890-1910 MHz \\ \cline{3-3} 
		& & 1910-1930 MHz \\ \cline{3-3} 
		& & 1970-1980 MHz \\ \cline{3-3} 
		& & 1980-1990 MHz \\ \hline
	\end{tabular}
	\caption{Tabla de Banda L \gc{RMEM} }
\end{table}

\clearpage\newpage

\input{Prototype}
\clearpage\newpage

\input{RCEM}
 
\clearpage\newpage

trellis and MER estimation + Signal Identification
\clearpage\newpage
\section*{\Large{SDR-based~Testbed~Environment}}

\begin{DefQuot}{1.2}
	{\textit{Software-Defined Radio} is a radio communication system in which any physical item or function can be performed or automated by software. \\
		
		Thus, SDR replaces traditional hardware components through software algorithms, enhancing flexibility and adaptability in radio systems, and enabling the development of CR prototypes and solutions. \\
		
		The testbed allows for the evaluation of communication protocols to be implemented in real-world scenarios \href{https://ieeexplore.ieee.org/abstract/document/9989359}{${\bullet}$}. 
		
}\end{DefQuot}
\medspace 
\begin{figure}[!ht] 
	\centering
%	\vspace*{2.1cm}
	\resizebox{.84\columnwidth}{!}{\input{Figures/SDRScheme}}
%	\caption{SDR functional diagram.}
\end{figure}
\clearpage\newpage
\paragraph*{SDR-based platform}
\begin{figure}[!ht] 
%	\vspace*{1.2cm}
	\centering
	\resizebox{.84\columnwidth}{!}{\input{Figures/SDRArchitecture}}
\end{figure}

\begin{description}
	\item[\textcolor{light-red}{Hardware}:] 	
	The hardware of an SDR transceiver usually contains components (processing devices) such as a general purpose processor (GPP), digital signal processing (DSP), and Field Programmable Gate Arrays (FPGA). A SDR device employs reconfigurable hardware that may be programmed over-the-air by software to function under different wireless standards. 
	
\begin{figure}[!ht] 
	\centering
	\resizebox{.57\columnwidth}{!}{\input{Figures/WlSDRPLatform}}
	\caption{Selection of SDR Platforms for Wireless Technologies.
		[\href{https://ieeexplore.ieee.org/abstract/document/9721283}{$\gc{\bullet}$}]
	}
\end{figure}

\item[Peripherals:] Auxiliary devices for Transmission/Reception of radio signals through reconfigurable hardware components (real-time processing devices, middleware, or Open-source electronic prototyping platforms)

-- \textsl{Antenna Reception System}, determining the signal's propagation characteristics and coverage area. 

-- \textsl{RF Components} such as to filter out unwanted frequencies, and amplify signals to a desired power level. 

\item[\textcolor{light-azul}{Software}] \,

-- \textsl{ Open source software}: GNU Radio provides signal-processing blocks that are interconnected to form a flow graph representing the implemented transceiver in software\newline
	
-- \textsl{Third-Party Software} Compatible with HackRF
	 Baseband Data Processing to extract meaningful information through relevant processing based on the application's requirements.	
	
-- \textsl{Control and Monitoring Interfaces} through GUI software, allowing to adjust and optimize TX/RX parameters in varying conditions.
	Post-processing outputs to make available the processed data for use by the application or sending to another system (display, storage unit) for further analysis or
	action.
\end{description}
 
\clearpage\newpage

\subsection{SDR-based Spectrum Sensing Platform} 
\begin{figure}[!ht] 
	\centering
	\resizebox{\columnwidth}{!}{\input{Figures/SDRpipeline.tikz}}
	\caption{Spectrum Sensing Prototype}
\end{figure}	

 \paragraph{Data Acquisition \& Peripherals} 
	\begin{itemize}
		\item \textsl{SDR Hardware}: \newline
	{\color[rgb]{0,.5,0}{\checkmark}} SDR Dongle: \texttt{HackRF~One}
	
	\begin{table}[!ht]
		\centering
		\small
		\begin{tabular*}{.9\columnwidth}{@{\extracolsep{\fill}} |l|lllll|}
			%\begin{tabular}{|l|l|l|l|l|l|}
			\hline
			~ & \textbf{USRP}	
			B210 & \textbf{LimeSDR} & {\texttt{HackRF~One}} & \textbf{ADALM		
				Pluto} & \textbf{RTL-SDR} \\ \hline
			\textsl{RF Range} & 70MHz-6GHz & 100kHz-3.8GHz & 1MHz-6GHz & 325MHz-3.8/6GHz & 500kHz-1.766GHz \\ 
			\textsl{Bandwidth} & 61.44 MHz & 61.44 MHz & 20 MHz & 20 MHz & 2.4 MHz \\ 
			\textsl{ADC} & 12 bits & 12 bits & {8 bits}\footnote{1. Poor representation format} & 12 bits & 8 bits \\
			\textsl{MIMO} & $2\times2$ & $2\times2$ & {none}\footnote{2. direct diversity reception excluded} & none & none \\
			\textsl{FPGA} & Xilinx		
			Spartan-6 & Altera	
			Cyclone IV & {none}\footnote{3. Poor processing capability} & Xilinx Zynq		
			Z-7010 & none \\ \hline
		\end{tabular*}
		\caption{Available SDR platforms}
		{ 1. Poor representation format\newline
			2. Straightforward diversity reception excluded\newline
			3. Poor processing capability\newline
		}
	\end{table}
	
		\halfcheckmark PC's sound card (ADC/DAC + PC processing) is free and easier to use for RF experimentation.
		
		\Cross Maia SDR that is a portable solution using Web-based interface accessed from a smartphone, PC or other device. \href{https://maia-sdr.org/}{${\bullet}$}
		\item
		\textsl{SW for Supporting SDR}: 
		\begin{list}{*}{}
			\item Drivers and Libraries to interface with the \texttt{HackRF~One} SDR: 
			
			\halfcheckmark GNU Radio\footnote{GNU Radio is a free \& open-source software development toolkit that provides signal processing blocks to implement SDR designs}
			
				{\color[rgb]{0,.5,0}{\checkmark}} Proprietary drivers developed in C from \texttt{HackRF~One} SD: libHackRf
			%Windows: SDR\# (SDRSharp) is very popular and user-friendly.Linux/macOS: GQRX or CubicSDR are good choices.
			
			{\color[rgb]{0,.5,0}{\checkmark}} Python. Collab \href{https://colab.research.google.com/}{${\bullet}$} Deepnote \href{https://colab.research.google.com/}{${\bullet}$}	
			\item Programming Environment developed for the Signal Processing and Recognition Group: 
			
			 {\color[rgb]{0,.5,0}{\checkmark}} python-chaski. An advanced distributed communication framework designed to streamline data exchange between nodes over TCP/IP networks. \href{https://github.com/dunderlab/python-chaski}{${\bullet}$}. 	
			 
			 {\color[rgb]{0,.5,0}{\checkmark}} python-dunderlab.foundation. A comprehensive Python framework designed to support modular and scalable applications, providing essential tools for data processing, communications, and system management. \href{https://github.com/dunderlab/python-dunerlab.foundation}{${\bullet}$}. 				
		\end{list}
\clearpage\newpage
				\textcolor{light-olive}{GNU Radio (Python Script))} of installing libraries for \texttt{HackRF~One}\href{https://deepnote.com/workspace/german-castellanos-dominguez-6c6a-246f99fc-b475-4d54-9a79-81e3601710af/project/ANE-8875a419-1789-4110-9f86-9e57021c79b7/notebook/DA001-ef65d5d92f91453d9b7efdebb3c8beb4}{$\textcolor{light-olive}{\bullet}$}. 
				
		\begin{python}
pip install pyhackrf
		\end{python}

\begin{python}
# Spectrum Sensing Script
			
import numpy as np 		# numerical operations
import matplotlib.pyplot as plt 		# visualization
from pyhackrf import HackRF
			
def main():
	# Initialize HackRF
	hackrf = HackRF()					# Initialize the SDR device.
			
	try:
		# Configure HackRF
		hackrf.sample_rate = 20e6	 # Set the sample rate to 2.4 MHz
		hackrf.center_freq = 100e6 # Set the center frequency to 100 MHz
		hackrf.gain = 40 # Gain level can be adjusted as needed
		#hackrf.gain = 'auto' # Automatically adjust the gain.
			
		# Read samples
		print("Reading samples from HackRF...")
		samples = hackrf.read_samples(1024*1024) 
		# Read 1M samples
			
	finally:
		# Ensure the HackRF is properly closed
		hackrf.close()
			
	if __name__ == "__main__":
		main()	
\end{python}
		
\item[\gc{ARxA}] \textsl{Antenna Reception Array} 
\begin{list}{*}{}	
			
\item \textsl{Single Antenna Reception}. Direct connection to \texttt{HackRF~One} having a single RF input/output 
\begin{list}{**}{}
	\item[\gc{ANT1}] Omni-directional antenna
	
	{\color[rgb]{0,.5,0}{\checkmark}} Omni-directional (adjustable, telescopic) reception antenna ANT500, covering frequencies from 75 MHz to 1 GHz
	
		\halfcheckmark High Gain Omni-Directional FM Reception Antenna
	\href{https://www.ebay.com/itm/223067751975?_nkw=Fm+Yagi+Antenna&itmmeta=01J63GC1XRQ1TP457QQEGTPA18&hash=item33efdfc627:g:4TMAAOSwP1JbUJj5&itmprp=enc%3AAQAJAAAA8HoV3kP08IDx%2BKZ9MfhVJKnUwTQyIJVYaOllyVytv6R5efqysqSDYWbS%2BQAoVFWBJxESPaxxYbYxunFuqgy4MtknKUu9nwTedKvMogd6clFZO6Bh1vxpobKyfrkBC4f77xeNmoOo2OT8spZTOGIuyxTi%2FuNEFWjPi9zc2ciyVpAX1EAYk4f4kfr%2FWb%2B8zEEM%2Fv00VuqDxeId5KhtNA8hqjUjTL%2F1vhnnxgQXELVy36%2BNRAbgTbQw2wo0PqNmyvIvI374TYT%2FCEakSfaqFSBm4ph8vuvo4W5hPDkjwtvoSllOmkB5BnJfvnItuLOtNp8D5Q%3D%3D%7Ctkp%3ABFBM-p6w8LBk}{${\bullet}$}
		
	\Cross Yagi Antenna, Discone Antenna, Log-Periodic Antenna, vertical ground plane antenna 			
	
	\item[\gc{ANT2}] Directional Antenna
	
	{\color[rgb]{0,.5,0}{\checkmark}} Taoglas TG.66.A113 A compact GPS antenna intended for navigation and geolocation applications, covering frequencies from 600 MHz to 6 GHz
	
\end{list}
				
\item \Cross \textsl{Two separate \texttt{HackRF~One} devices + Synchronization.} Each SDR is connected to a separate antenna, involving external clock sources or custom synchronization circuits (e.g., for MIMO or coherent signal processing), as \texttt{HackRF~One} does not natively support phase synchronization across multiple units. 

\item \halfcheckmark \textsl{Dual antenna time-multiplexed SDR system.} Two antennas are used in conjunction with a time multiplexing technique to share resources such as a single SDR receiver or transmitter. Synchronization is also required by Software Integration. Time-division multiplexing is used to alternate between the two antennas, allowing each to transmit or receive signals in different time slots, without the need for two separate SDR channels.
			
\begin{figure}[!ht] 
				\centering
				\resizebox{.72\columnwidth}{!}{\includegraphics{Figures/AntennaMux.png}}
				\caption{Antenna Multiplex System\href{https://www.ursi.org/proceedings/procGA02/papers/p1879.pdf}{${\bullet}$}}
\end{figure}
			
\textcolor{light-olive}{GNU Radio (Python Script)
			\href{https://deepnote.com/workspace/german-castellanos-dominguez-6c6a-246f99fc-b475-4d54-9a79-81e3601710af/project/ANE-8875a419-1789-4110-9f86-9e57021c79b7/notebook/DA002-8a9fa3f33b8642bea091b21c66a08eea}{${\bullet}$}}. 
			
Considerations:\newline
Time Accuracy: Depending on your application, more precise control over time multiplexing maybe needed. Timers or hardware interrupts are used to ensure accurate time control.\newline
Antenna Latency Switching: Some SDR devices have some delays when switching antennas. The switching time for hardware must be tested to ensure it meets MUX requirements.
			
\item[\gc{DASw}] {\color[rgb]{0,.5,0}{\checkmark}} \textsl{Dual Antenna Switch} \href{https://www.dxengineering.com/parts/dmn-cx310a}{${\bullet}$}.
		 An external RF switch controlled by an Raspberry Pi GPIO on the \texttt{HackRF~One} is used to toggle between two antennas connected to the RF switch. \texttt{HackRF~One} has four GPIO pins (labeled GPIO4, GPIO5, GPIO6, and GPIO7) used to control external hardware like an RF switch.
		 
		 \textcolor{light-olive}{GNU Radio (Python Script)
		 	\href{https://deepnote.com/workspace/german-castellanos-dominguez-6c6a-246f99fc-b475-4d54-9a79-81e3601710af/project/ANE-8875a419-1789-4110-9f86-9e57021c79b7/notebook/DA003-9da262e37be94cb29a1bf117b44f8bdd}{${\bullet}$}}. 		 
 
Consideration\newline
Depending on each application, the switching time may be a concern. Some RF switches might have delays or require debounce logic, especially for fast switching applications.

\halfcheckmark Enhanced Reception
\begin{list}{**}{}
	\item Two omni-antennas for Diversity Reception or Scanning Different Bands 
	
%	\gc{Band1}, \gc{Band4}\rojo{falta}
	\item Two Directional Signal Analysis (one directional antenna (e.g., Yagi) towards a specific signal source, while the other (e.g., omnidirectional) covers a broader area) 
	
	%\gc{Band2}\rojo{falta}
	\item FM DX to receive distant or rare FM stations, including the use of UAVs. 
\end{list} 
\end{list}
\item \halfcheckmark \textsl{Antenna Rotator} to monitor stations from different directions, allowing to remotely adjust the antenna's direction. Controlling an antenna rotator involves interfacing with external hardware (e.g., using an Raspberry Pi), or some specific serial interface to rotate the antenna to a desired azimuth and/or elevation.

Considerations:\newline
Precision Control of the rotator to accurately respond to azimuth commands. Some rotators may have slight delays, so you there is a need for experimenting with time.sleep() to give the rotator enough time to move.\newline
Signal Strength Integration by processing the \texttt{HackRF~One}'s received samples after each rotation to decide if further adjustments are needed.

\textcolor{light-olive}{GNU Radio Python Script to Control Antenna Rotator
	\href{https://deepnote.com/workspace/german-castellanos-dominguez-6c6a-246f99fc-b475-4d54-9a79-81e3601710af/project/ANE-8875a419-1789-4110-9f86-9e57021c79b7/notebook/DA004-45f08e847b884f5ba53bd5e34283e289}{${\bullet}$}}. 

\item[\gc{GPSSync}] {\color[rgb]{0,.5,0}{\checkmark}} Multi Sensor GPS-based Synchronization 
\href{http://spcomnav.uab.es/docs/conferences/Bartolucci_NAVITEC_2016.pdf}{${\bullet}$} 

\begin{figure}[!ht] 
	\centering
	\resizebox{.9\columnwidth}{!}{\input{Figures/MultiBandMon}}
	\caption{Global Synch Scheme}
\end{figure}
\end{itemize} 
\textcolor{light-olive}{GNU Radio for GPS-based Synchronization (Python Script)
	\href{https://github.com/gnss-sdr/gnss-sdr}{${\bullet}$}}. 

\begin{table}[h!]
	\vspace*{1.2cm}
	\centering
	\begin{tabular}{|c|c|c|c|c|}
		\hline
		 & \textbf{Bandwidth} & \textbf{DASw} & \textbf{ARxA} & \textbf{GPSSync} \\ \hline
		VHF 1 & 88MHz - 108MHz & No & ANT 1 & Yes \\ \hline
		VHF 2 & 137MHz - 144MHz & No & ANT 1 & Yes \\ \cline{1-5} 
		VHF 3 & 148MHz - 174MHz & No & ANT 1 & Yes \\ \cline{1-5} 
		UHF 1 & 400MHz - 470MHz & No & ANT 1 & Yes \\ \cline{1-5} 
		UHF 2 & 470MHz - 512MHz & No & ANT 1 & Yes \\ \hline
		UHF 3 & 1GHz - 2GHz & No & ANT 2 & Yes \\ \hline
		SHF 1 & 2555 MHz - 2680 MHz & No & ANT 2 & Yes \\ \hline
		SHF 2 & 3300 MHz - 3620 MHz & No & ANT 2 & Yes \\ \hline
	\end{tabular}
	\caption{Tabla de Notation, Bandwidth, Dual Antenna Switch, ArxA y MGPSync}
\end{table}

\clearpage\newpage
\paragraph{Signal Processing \& Radio Scanning} 
\medspace
\begin{figure}[!ht] 
	\centering		
	%{\resizebox{.57\columnwidth}{!}{\includegraphics{Figures/FreqScanning}}} 
	%\resizebox{\columnwidth}{!}{\input{Figures/FreqScanning0}}
	\resizebox{\columnwidth}{!}{\input{Figures/RadioScanning}}
	\caption{Radio Scanning Pipeline}
\end{figure}

\begin{itemize}

\item[\gc{Demod}] {\color[rgb]{0,.5,0}{\checkmark}} \textsl{Demodulation}

Basic reception structures to convert RF signals into baseband signals for further processing:
\begin{figure}[!htb]
	\centering
	\begin{minipage}{.5\textwidth}
		\centering
		\resizebox{.93\columnwidth}{!}{
			\begin{tikzpicture}[node distance=2cm]
				% Nodes
				\node (antenna) [triangled] {};
				\node (lna) [triangler, fill=green!40, right=2cm of antenna, xshift=1cm, yshift=1cm] {\rotatebox{90}{LNA}};
				\node (multi) [circlex, fill=yellow!30, right=2cm of lna, xshift=0.3cm, yshift=0.8cm]{};
				\node (filter) [box, fill=blue!30, right=2cm of multi, xshift=-0.7cm]{Filter};
				\node (adc) [poligon, fill=blue!30, right=2cm of filter, xshift=-0.7cm]{ADC};
				\node (lo) [circles, fill=yellow!30, below=1cm of multi]{LO};
				\node[textbox] (text1) at (6,0.8) {\textbf{ADC or Analog Demod}};
				
				% Draws
				\draw [arrow] (antenna) |- (lna);
				\draw [arrow] (lna) -- (multi);
				\draw [arrow] (multi) -- node[anchor=south, black] {\textbf{I}}(filter);
				\draw [arrow] (filter) -- (adc);
				\draw [arrow] (lo) -- (multi);
				
			\end{tikzpicture}
		}
		\caption{Homodyne receiver}
		\label{fig:prob1_6_2}
	\end{minipage}%
	\begin{minipage}{0.5\textwidth}
		\centering
		\resizebox{.93\columnwidth}{!}{
			\begin{tikzpicture}[node distance=2cm]
				% Nodes
				\node (antenna) [triangled] {};
				\node (lna) [triangler, fill=green!40, right=2cm of antenna, xshift=1cm, yshift=1cm] {\rotatebox{90}{LNA}};
				\node (multi1) [circlex, fill=yellow!30, right=2cm of lna, xshift=0.3cm, yshift=0.8cm]{};
				\node (filter1) [box, fill=blue!30, right=2cm of multi1, xshift=-0.7cm]{Filter};
				\node (adc1) [poligon, fill=blue!30, right=2cm of filter1, xshift=-0.7cm]{ADC};
				
				\node (multi2) [circlex, fill=yellow!30, below=1.5cm of multi1]{};
				\node (shift) [box, fill=yellow!30, below=1cm of multi2, xshift=-2cm]{90 shift};
				\node (lo) [circles, fill=yellow!30, left=1cm of shift]{LO};
				\node (filter2) [box, fill=blue!30, right=2cm of multi2, xshift=-0.7cm]{Filter};
				\node (adc2) [poligon, fill=blue!30, right=2cm of filter2, xshift=-0.7cm]{ADC};
				\node[textbox] (text1) at (6.5,1) {\textbf{Direct conversion (Zero IF)}};
				
				% Draws
				\draw [arrow] (antenna) |- (lna);
				\draw [arrow] (lna) -- (multi1);
				\draw [arrow] (multi1) -- node[anchor=south, black] {\textbf{I}}(filter1);
				\draw [arrow] (filter1) -- (adc1);
				
				\draw [->, blue!40] (lo) -- ++(0,3) -| (multi1);
				\draw [arrow] (lo) -- (shift);
				\draw [arrow] (shift) -| (multi2);
				\draw [arrow] (multi2) -- node[anchor=south, black] {\textbf{Q}} (filter2);
				\draw [arrow] (filter2) -- (adc2);
				\draw [arrow] (lna) |- (multi2);
				
		\end{tikzpicture}}
		\caption{Heterodyne receiver}
	\end{minipage}
		\caption{By default, \texttt{HackRF~One} SDR uses heterodyne architecture in the front-end.}
\end{figure}
\begin{list}{*}{}
	\item[\gc{HomoRx}] \textsl{Homodyne receiver} converts directly the RF signal to baseband without any intermediate frequency stage (Zero-IF), which is more suited for SDR devices focused on DSP. It provides high sensitivity and better image rejection due to the use of FI stages, but is more complex. However, imperfect in-phase (I) and quadrature (Q) signals can cause IQ imbalance, leading to signal degradation.
	
	\item[\gc{HeteRx}] \textsl{Heterodyne receiver} is the process of converting an incoming high-frequency ($f_{RF}$) signal to an intermediate frequency ($f_{IF}$) before it is down-converted to baseband $f_{BB}$. The mixer output in a heterodyne receiver is $f_{IF}{=} \mid f_{RF} {-} f_{BB}\mid$		
\end{list}

\clearpage\newpage

\item[\gc{Samp}] \textsl{Sampling} 
\begin{list}{*}{}
	\item[\gc{OverSam}] {\color[rgb]{0,.5,0}{\checkmark}} Oversampled Nyquist Sampling [Oversampling]. The sample rate must be at least twice the highest frequency component of the signal to accurately reconstruct the signal without aliasing. 
	\item[\gc{UnderSam}] {\color[rgb]{0,.5,0}{\checkmark}} Undersampled Nyquist Sampling [Undersampling]. Bandpass sampling is a technique where one samples a bandpass-filtered signal at a sample rate below its Nyquist rate. The sample rate is few times under Nyquist rate because of hardware restrictions. 
\end{list}

\textcolor{light-olive}{GNU Radio. Python Script for Heterodyne receiver
	\href{https://deepnote.com/workspace/german-castellanos-dominguez-6c6a-246f99fc-b475-4d54-9a79-81e3601710af/project/ANE-8875a419-1789-4110-9f86-9e57021c79b7/notebook/DA005a-af7a8d817cda453a86f7a5ac67fcd126}{${\bullet}$}}. 
\medspace
\begin{python}
# Block 1: 		Signal Source captures the signal.
# Block 2: 		Filtering applies a low-pass filter to isolate the IF signal.
# Block 3: 		Data Storage the filtered IF data.
	
	class if_data_acquisition(gr.top_block):
	def __init__(self):
	gr.top_block.__init__(self, "IF Data Acquisition")
	
	# Parameters
	center_freq = 100e6 	# center radio frequency at 100MHz
	samp_rate = 2e6 		# sampling rate at 2Mps
	
	# Block 1
	self.src = osmosdr.source(args="numchan=1")
	self.src.set_sample_rate(samp_rate)
	self.src.set_center_freq(center_freq)
	self.src.set_gain(30)
	
	# Block 2
	# Low-pass filter to isolate the IF signal
	self.lp_filter = filter.fir_filter_ccf(1, 
	filter.firdes.low_pass(1, samp_rate, 200e3, 10e3, filter.firdes.WIN_HAMMING, 6.76))
	
	# Block 3
	# File sink to store the IF data
	self.file_sink = blocks.file_sink(gr.sizeof_gr_complex*1, "if_data.bin")
	
	# Connections
	self.connect(self.src, self.lp_filter, self.file_sink)
\end{python}

	\item[\gc{RedSamp}] 
\textsl{Reduced Rate Sampling}: 

\begin{list}{*}{}
	\item[\gc{Decim}] {\color[rgb]{0,.5,0}{\checkmark}} Decimation. In wideband RF systems, the initial sample rate may be very high (e.g., several MHz) to capture a wide range of frequencies. Decimation is used to reduce the sample rate for more manageable processing while preserving the signal of interest.
	
	 \textcolor{light-olive}{GNU Radio. Python Script for decimation \href{https://deepnote.com/workspace/german-castellanos-dominguez-6c6a-246f99fc-b475-4d54-9a79-81e3601710af/project/ANE-8875a419-1789-4110-9f86-9e57021c79b7/notebook/DA005d-3671173457604c74978f720c0839010b}{${\bullet}$}}. 
	\item[\gc{Interp}] {\color[rgb]{0,.5,0}{\checkmark}} Interpolation can be used to increase the sample rate if necessary for specific processing stages. 
	
	\textcolor{light-olive}{GNU Radio. Python Script for Wavelet Interpolation
		\href{https://deepnote.com/workspace/german-castellanos-dominguez-6c6a-246f99fc-b475-4d54-9a79-81e3601710af/project/ANE-8875a419-1789-4110-9f86-9e57021c79b7/notebook/DA005e-c89573cfb12249bca0fd35358943d5f0}{${\bullet}$}}. 
\end{list}

	\item[\gc{ModType}] Information Signal Format \newline
	\begin{list}{*}{}
		\item[\gc{Analog}] Analog Signal
		\item[\gc{Digital}] Digital Signal
	\end{list}
	
	\begin{table}[!ht]
		\centering
		\begin{tabular}{|c|c|c|c|c|}
			\hline
			\textbf{Notation} & \textbf{Scheme} & \textbf{Mod Type} & \textbf{Samp} & \textbf{RedSamp} \\ \hline
			VHF 1 & Homodyne & Analog & OverSam & Decimation \\ \hline
			VHF 2 & Homodyne & Analog & OverSam & Decimation \\ \hline
			VHF 3 & Homodyne & Analog & OverSam & Decimation \\ \hline
			UHF 1 & Heterodyne & Digital & OverSam & Decimation \\ \hline
			UHF 2 & Heterodyne & Digital & OverSam & Decimation \\ \hline
			UHF 3 & Heterodyne & Digital & OverSam & Decimation \\ \hline
			SHF 1 & Heterodyne & Digital & OverSam & Decimation \\ \hline
			SHF 2 & Heterodyne & Digital & UndersSam & Decimation \\ \hline
		\end{tabular}
		\caption{Tabla de Notation, Scheme, Mod Type, Samp y RedSamp}
	\end{table}
\clearpage\newpage

\item \textsl{Flow Control of RF Scanning}
 
 \begin{list}{*}{}
 	\item \textsl{Carrier \& Bandwidth Setting}\newline
 	Adjusting Input Settings: \rojo{falta enumerar todos los parametros}
 	
 	\begin{list}{**}{}
 		\item[\gc{ModBandwidth}] Bandwidth to capture the modulated signal.
 		\item[\gc{InitSRate}] Initial Sample Rate
 		\item[\gc{AudioSRate}] Audio Sample Rate
 		\item[\gc{Gain}] 
 		Gain Control settings within the SDR software to balance signal strength with noise reduction. 
 		 \item[\gc{LPFil}] \textsl{Low-Pass Filter} for removing high-frequency noise and unwanted components.
 		
 		\begin{python}
 			from gnuradio import filter 
 			
 			# Low-pass filter to remove high-frequency components
 			lpf = filter.fir_filter_ccf(1, filter.firdes.low_pass(1, sample_rate, 100e3, 10e3))
 		\end{python}
 	 \item[\gc{FreqScaling}] \textsl{Frequency scaling}:\newline 
 	This procedures in SDR involves adjusting the sampling rate to match the frequency of interest for effectively capturing and processing signals, especially when dealing with different frequency bands.
 	
 	\begin{list}{**}{}
 		\item[\gc{NonOver}] Non-overlapped channel scaling
 		\item[\gc{Overlap}] Overlapping by slicing window
 	\end{list}
 	\textcolor{light-olive}{GNU Radio. Python Script for Frequency scaling \href{https://deepnote.com/workspace/german-castellanos-dominguez-6c6a-246f99fc-b475-4d54-9a79-81e3601710af/project/ANE-8875a419-1789-4110-9f86-9e57021c79b7/notebook/DA005f-cf5ba8f22996475ba4d668e37cb07314}{${\bullet}$}}. 
 	\end{list}

 \item {\color[rgb]{0,.5,0}{\checkmark}} \textsl{Throttling}\newline
 This block is added for controlling the flow of data to match the processing rate. Throttling is used to control the rate at which operations are performed, ensuring that the system does not get overwhelmed by too many requests in a short period. 
 
 Specific aspects of throttling in SDR:
 
 .- \textsl{Sample Rate Control}: SDR systems often need to process signals at specific sample rates. A throttling block can ensure that samples are produced or consumed at a constant rate, matching the desired sample rate of the system.
 
 .- \textsl{Buffer Management}: In SDR, data is often processed in chunks or buffers. Throttling helps manage these buffers to ensure that they do not overflow (too much data too quickly) or underflow (too little data too slowly).
 
 .- \textsl{Synchronization}: Ensures that different components of the SDR system, which may operate at different rates, remain in sync. For instance, the rate at which data is received from an antenna must be synchronized with the rate at which it is processed and possibly transmitted.
 
 .- \textsl{Flow Graph Control}: In many SDR platforms like GNU Radio, flow graphs (which represent the data flow through various processing blocks) include throttling blocks to control the overall flow of data through the graph. This ensures that each block processes data at the correct rate.
 
 .- \textsl{CPU Load Management}: Throttling can also be used to manage CPU load. By controlling the rate of data processing, the system can avoid overloading the CPU, ensuring stable operation.
 
 \textcolor{light-olive}{GNU Radio. Python Script for Throttling \href{https://deepnote.com/workspace/german-castellanos-dominguez-6c6a-246f99fc-b475-4d54-9a79-81e3601710af/project/ANE-8875a419-1789-4110-9f86-9e57021c79b7/notebook/DA005g-00ae3678088b482daeb0bfd087c602cc}{${\bullet}$}}. 
 
 \end{list}
 


%\begin{itemize} 
% 	\item[\gc{Band1}:] Parameter setting 
% 	
% .- \textsl{bandwidth} 200 kHz
% 	
% .- \textsl{Initial Sample Rate}: the highest frequency component typically includes the carrier plus the deviation caused by the audio signal. Sample Rate in the range of 1.024 to 2.048 Mps. 
% 
% .- \textsl{Audio Sample Rate}: Typically 44.1 kHz or 48 kHz for high-quality audio output.
% 	
% .- BB content of fm. Audio + RDS (Radio Data System). Some SDR software can decode RDS, which is the digital information transmitted by FM radio stations, including station names, song information, etc. 
 	
\textcolor{light-olive}{GNU Radio for FM demodulation
 		\href{https://deepnote.com/workspace/german-castellanos-dominguez-6c6a-246f99fc-b475-4d54-9a79-81e3601710af/project/ANE-8875a419-1789-4110-9f86-9e57021c79b7/notebook/DA005b-b3d38d38b73548f99256866db748e898}{${\bullet}$}}.
 	
\textcolor{light-olive}{GNU Radio for FM demodulation from a simulated source
 		\href{https://deepnote.com/workspace/german-castellanos-dominguez-6c6a-246f99fc-b475-4d54-9a79-81e3601710af/project/ANE-8875a419-1789-4110-9f86-9e57021c79b7/notebook/DA005c-caccd56cdb5149b5a06537aa199f2111}{${\bullet}$}}.
 		
\textcolor{light-olive}{GNU Radio for Quadrature FM Demodulator
 		\href{https://deepnote.com/workspace/german-castellanos-dominguez-6c6a-246f99fc-b475-4d54-9a79-81e3601710af/project/ANE-8875a419-1789-4110-9f86-9e57021c79b7/notebook/DA005b-3-6cf1936cbcf94851b28e0ba726e717b4}{${\bullet}$}}. \rojo{vH-perla IF}
%	
% 	\item[\gc{Band2}:] \rojo{falta}		
% 	
% 	\item[\gc{Band3}:] \rojo{falta}	
% 	
% 	\item[\gc{Band4}:] \rojo{falta}	
% 	
% 	\item[\gc{Band5}:] \rojo{falta}	
%
%\end{itemize}
\end{itemize}
\clearpage\newpage
\paragraph{Signal Processing \& Estimation Tasks} 
 
 \begin{itemize}
 	\item \textsl{PSD Estimation.} 
 	Real-Time Implementation of Multiband Spectrum Sensing Using SDR
 	\href{https://www.mdpi.com/1424-8220/21/10/3506}{${\bullet}$} 
 	\begin{list}{*}{}
 		\item \halfcheckmark Multi-taper Method of PSD. Estimation based on multiple orthogonal tapers to reduce spectral leakage and variance.
 		
 		\textcolor{light-olive}{GNU Radio for PSD -- Multi-taper Method
 			\href{https://deepnote.com/workspace/german-castellanos-dominguez-6c6a-246f99fc-b475-4d54-9a79-81e3601710af/project/ANE-8875a419-1789-4110-9f86-9e57021c79b7/notebook/DA006a-99eea3209ecf4a188e9faf545908a2cb}{${\bullet}$}}.
 		\item \halfcheckmark Wavelet-based PSD estimation with denoising.
 		
 		\textcolor{light-olive}{GNU Radio for PSD -- Wavelet
 			\href{https://deepnote.com/workspace/german-castellanos-dominguez-6c6a-246f99fc-b475-4d54-9a79-81e3601710af/project/ANE-8875a419-1789-4110-9f86-9e57021c79b7/notebook/DA006c-5642732f7a2746bca9ec65e8005cb21a}{${\bullet}$}}. 
 		\item {\color[rgb]{0,.5,0}{\checkmark}} Welch's Method. Based on averaged histograms
 		
 		\textcolor{light-olive}{GNU Radio for PSD -- Welch's Method
 			\href{https://deepnote.com/workspace/german-castellanos-dominguez-6c6a-246f99fc-b475-4d54-9a79-81e3601710af/project/ANE-8875a419-1789-4110-9f86-9e57021c79b7/notebook/DA006b-85b5afa3a0e74113a2b93426013f0385}{${\bullet}$}}.
 		
 		\item {\color[rgb]{0,.5,0}{\checkmark}} Neural Network-based Estimation
 		
 		\textcolor{light-olive}{GNU Radio for PSD -- Neural Networks
 			\href{https://deepnote.com/workspace/german-castellanos-dominguez-6c6a-246f99fc-b475-4d54-9a79-81e3601710af/project/ANE-8875a419-1789-4110-9f86-9e57021c79b7/notebook/DA006d-ff64306bc6874291bd53409b5a03d1ee}{${\bullet}$}}. 
 	\end{list}

\!
\begin{linenomath*}
	\begin{align*} 
		x(t) \in \mathcal{L}_2(\Real)\quad \textrm{nonrandom signal}\to	 \textrm{FT: } &\quad\mathcal{F}\{x(t)\}= X(\omega)\in \mathbb{C}\\
		\textrm{FT}\to\textrm{DFT}\to\textrm{FFT}&
		\quad \textrm{\textsl{Energy Spectral Density} }\to \textrm{\gc{Calculation}}\\
		\xi(t) \in \mathcal{L}_2(T)\quad \textrm{random signal}\to S_\xi(\omega) = \promed{\mathcal{F}_T\{\xi\}}
		&\quad\textrm{\textsl{Power Spectral Density}}\to \textrm{\gc{Estimation}}\\
		\textrm{Statistical Estimation}\to\textrm{Welsh's Method} &
		\quad \textrm{Heuristic Estimation}\to\textrm{MLP}
	\end{align*}
\end{linenomath*}

\begin{figure}[!h]
	\centering
	\vspace*{-.9cm}
	\begin{tikzpicture}[
		plain/.style={
			draw=none,
			fill=none,
		},
		dot/.style={draw,shape=circle,minimum size=1.5pt,inner sep=0,fill=black
		},
		net/.style={
			matrix of nodes,
			nodes={
				draw,
				circle,
				inner sep=9pt
			},
			nodes in empty cells,
			column sep=0.6cm,
			row sep=-12pt
		},
		>=latex
		]
		\matrix[net] (mat)
		{
			|[plain]| \parbox{1cm}{\scriptsize\centering Input\\layer} 
			& |[plain]| \parbox{1cm}{\scriptsize\centering Hidden\\layer} 
			& |[plain]| \parbox{1cm}{\scriptsize\centering Output\\layer} \\
			& |[plain]| \\
			|[plain]| & & |[plain]| \\
			& |[plain]| & \\
			|[plain]| & |[dot]| \\
			& |[plain]| & |[dot]| \\
			|[plain]| & |[dot]| & |[plain]| \\
			|[dot]| & |[plain]| & |[dot]| \\
			|[dot]| & |[dot]| & |[plain]| \\
			|[dot]| & |[plain]| & \\
			|[plain]| & & |[plain]| \\
			& |[plain]| \\
		};
		\foreach \ai/\mi in {2/\scriptsize$\xi_1$,4/\scriptsize$\xi_2$,6/\scriptsize$\xi_3$,12/\scriptsize$\xi_T$}
		\draw[<-] (mat-\ai-1) -- node[above] {\mi} +(-.9cm,0);
		\foreach \ai in {2,4,6,12}
		{\foreach \aii/\mii in {3/\scriptsize$h_1$,11/\scriptsize$h_T$}
			\draw[->] (mat-\ai-1) -- (mat-\aii-2) node[yshift=0.6cm] {\mii};
		}
		\foreach \ai in {3,11}
		{ \draw[->] (mat-\ai-2) -- (mat-4-3);
			\draw[->] (mat-4-3) -- node[above] {\scriptsize$\hat{S}_\xi(\omega_1)$} +(1.8cm,0);}
		\foreach \ai in {3,11}
		{ \draw[->] (mat-\ai-2) -- (mat-10-3);
			\draw[->] (mat-10-3) -- node[above] {\scriptsize$\hat{S}_\xi(\omega_S)$} +(1.8cm,0);}
		\node[draw,align=left] at (0,-4.2) {\small \gc{MLP architecture for PSD Estimation}};	
	\end{tikzpicture}
\end{figure}

 
 	\item \textsl{Power Strength Estimation}
 
\begin{itemize}
	\item
	Source Block: ${'osmosdr.source'}$ or equivalent.
	\item
	Frequency Translation 
	\item
	Demodulation 
	\item
	Power Calculation 
\end{itemize}
	\textcolor{light-olive}{GNU Radio for Power Strength Estimation
	\href{https://deepnote.com/workspace/german-castellanos-dominguez-6c6a-246f99fc-b475-4d54-9a79-81e3601710af/project/ANE-8875a419-1789-4110-9f86-9e57021c79b7/notebook/DA007-79fac29d13a64a82b5c79f057117d284}{${\bullet}$}}. 
 
 	\item \textsl{Signal-to-Noise ratio -- S/N} 
 	 
 	Real-time computation \textcolor{light-olive}{GNU Radio for S/N
 		\href{https://deepnote.com/workspace/german-castellanos-dominguez-6c6a-246f99fc-b475-4d54-9a79-81e3601710af/project/ANE-8875a419-1789-4110-9f86-9e57021c79b7/notebook/DA008-fff0a7f665f841baa87011a60437d22e}{${\bullet}$}}. 

	\item \textsl{Energy Detection or Thresholding}

{Detecci\'on de canal}: Valor reportado: presencia -- 1 , ausencia -- 0 por canal

\begin{list}{*}{}
			\item 
			Energy Detection by $L_2$-based estimation and Entropy-based detection
			
			\textcolor{light-olive}{GNU Radio for Thresholding
				\href{https://deepnote.com/workspace/german-castellanos-dominguez-6c6a-246f99fc-b475-4d54-9a79-81e3601710af/project/ANE-8875a419-1789-4110-9f86-9e57021c79b7/notebook/DA009-63b205ed596a430f9c88cc914a7694ce}{${\bullet}$}}. 
			\item 
			Energy detection-based spectrum sensing machine
			\href{https://link.springer.com/chapter/10.1007/978-981-99-2710-4_24}{$\gc{\bullet}$}
			%\item[\checkmark] Shape signal Detection : correlation, cyclostationarity, covariance, waveform-based
			%\item[\checkmark] Matched Filter ($L_2$-based filtering)
			%\item[\checkmark] Matrix decomposition-based (eigenvalue detection)
			\item 
			Maximizing Eigenvalue Using Machine Learning
			\href{https://www.ijisae.org/index.php/IJISAE/article/view/3654}{$\gc{\bullet}$}
			\item 
			FlashFFTConv \href{https://medium.com/@multiplatform.ai/stanford-researchers-introduced-flashfftconv-to-optimize-fft-convolutions-for-long-sequences-in-3ce8706517a8}{$\gc{\bullet}$}
			\item 
			 Energy detection under noise power
			\href{https://www.sciencedirect.com/science/article/pii/S1110016822008018}{$\gc{\bullet}$} 
			\item 
			Multiscale Wavelet Transform Extremum Detection With the Spectrum Energy Detection
			\href{https://ieeexplore.ieee.org/abstract/document/10238706}{$\gc{\bullet}$}
			\item 
			Exploring DL for Adaptive Energy Detection Threshold Determination: A Multistage Approach
			\href{https://www.mdpi.com/2079-9292/12/19/4183}{$\gc{\bullet}$}
			\item 
			{\color[rgb]{0,.5,0}{\checkmark}} Deep Learning for Adaptive Energy Detection Threshold
			\href{https://www.mdpi.com/2079-9292/12/19/4183}{$\gc{\bullet}$}
\end{list}

\item \textsl{Signal Classification}\rojo{falta}

\item \textsl{Wideband Signal Processing} \rojo{falta}

Channelization, filter banks, and multichannel sensing
 
\item \textsl{Two-antenna diversity}

\begin{list}{*}{}
	\item By equal gain combining,

.-	Two SDR Source blocks for the two antennas.\newline
.-	Two Complex to MagPhase blocks to extract magnitude and phase.\newline
.-	Add, Multiply, and Complex Multiply blocks to align phases and combine signals.\newline
.-	A Sink block (e.g., FFT Sink, QT GUI Sink) to visualize the combined signal.

\textcolor{light-olive}{GNU Radio for Two-antenna diversity--equal gain combining
	\href{https://deepnote.com/workspace/german-castellanos-dominguez-6c6a-246f99fc-b475-4d54-9a79-81e3601710af/project/ANE-8875a419-1789-4110-9f86-9e57021c79b7/notebook/DA009-63b205ed596a430f9c88cc914a7694ce}{${\bullet}$}}.
	\item By maximal ratio combining.
		
	.-	Setup SDR Receivers: Configure two SDR devices to receive signals simultaneously.\newline
	.-	Calculate Weights: Calculate the optimal weights based on the received signal strengths.
	\newline
	.-	Maximal Ratio Combining: Combine the signals using the calculated weights.
	
	\textcolor{light-olive}{GNU Radio for Two-antenna diversity--equal gain combining
		\href{https://deepnote.com/workspace/german-castellanos-dominguez-6c6a-246f99fc-b475-4d54-9a79-81e3601710af/project/ANE-8875a419-1789-4110-9f86-9e57021c79b7/notebook/DA010b-20014e2a2fd4469185372a2b575741af}{${\bullet}$}}.
\end{list}

\end{itemize}


%\item
% \gc{Spectrum Analyzer}
%	\href{https://github.com/xmikos/qspectrumanalyzer}{$\gc{\bullet}$}
%
%Osmocom (open source mobile communications) is an open-source software project that implements multiple mobile communication standards
%
%.-	Device Arguments: rtl=0
% \begin{python}
% 	self.osmosdr_source = osmosdr.source(args="numchan=1 rtl=0")
% \end{python}
%.-	Sample Rate: 2M (or as per hardware capabilities)\newline
%.-	Center Frequency ( Match the center frequency of the Osmocom Source): 100M (or as per interest)\newline
%.-	Gain: 10
%\bigskip
% \begin{python}
% # FFT computation
% 
%from gnuradio import gr, blocks, analog, filter, fft
%import osmosdr
%	
%class spectral_calculation(gr.top_block):
%	 def __init__(self):
%	 gr.top_block.__init__(self, "Spectral Computation")
%	
%	 # Parameters
%	 samp_rate = 2e6
%	 center_freq = 100e6
%	
%	 # Source block
%	 self.src = osmosdr.source(args="numchan=1")
%	 self.src.set_sample_rate(samp_rate)
%	 self.src.set_center_freq(center_freq)
%	 self.src.set_gain(30)
%	
%	 # FFT block
%	 self.fft_size = 1024
%	 self.fft = fft.fft_vcc(self.fft_size, True, (), True)
%	
%	 # Stream to Vector for FFT
%	 self.stream_to_vector = blocks.stream_to_vector(gr.sizeof_gr_complex*1, self.fft_size)
%	
%	 # Probe Signal for Output
%	 self.probe = blocks.probe_signal_vf()
%	
%	 # Connections
%	 self.connect(self.src, self.stream_to_vector, self.fft, self.probe)
%	
%	if __name__ == '__main__':
%	 tb = spectral_calculation()
%	 tb.start()
%	 tb.wait()
%	 # Example to read FFT output
%	 fft_output = tb.probe.level()
%	 print("FFT Output:", fft_output)
%\end{python}
%
%\clearpage\newpage
%
%.-	Source Block: Set the frequency, sample rate, and other parameters specific to your SDR.\newline
%.-	Throttle Block: Set the sample rate to match your source.\newline
%.-	FFT Sink: Configure the FFT parameters (e.g., FFT size, averaging, etc.).
% 
% 	\begin{python}
%# FFT Spectrum Analyzer
%
%from gnuradio import gr, blocks, fft, analog
%from gnuradio import eng_notation
%from gnuradio.fft import window
%from gnuradio.filter import firdes
%import osmosdr
%import time
%
%class top_block(gr.top_block):
%
% def __init__(self):
% gr.top_block.__init__(self, "FFT Spectrum Analyzer")
%
% # Variables
% ##################################################
% self.samp_rate = samp_rate = 1e6
% self.freq = freq = 100e6
%
% # Blocks
% ##################################################
% self.rtlsdr_source_0 = osmosdr.source(args="numchan=1")
% self.rtlsdr_source_0.set_sample_rate(samp_rate)
% self.rtlsdr_source_0.set_center_freq(freq, 0)
% self.rtlsdr_source_0.set_freq_corr(0, 0)
% self.rtlsdr_source_0.set_dc_offset_mode(0, 0)
% self.rtlsdr_source_0.set_iq_balance_mode(0, 0)
% self.rtlsdr_source_0.set_gain_mode(False, 0)
% self.rtlsdr_source_0.set_gain(10, 0)
% self.rtlsdr_source_0.set_if_gain(20, 0)
% self.rtlsdr_source_0.set_bb_gain(20, 0)
% self.rtlsdr_source_0.set_antenna("", 0)
% self.rtlsdr_source_0.set_bandwidth(0, 0)
%
% self.throttle_0 = blocks.throttle(gr.sizeof_gr_complex*1, samp_rate,True)
% self.fft_vxx_0 = fft.fft_vcc(1024, True, (window.blackmanharris(1024)), True, 1)
% self.stream_to_vector_0 = blocks.stream_to_vector(gr.sizeof_gr_complex*1, 1024)
% self.complex_to_mag_squared_0 = blocks.complex_to_mag_squared(1024)
% self.sink = blocks.vector_sink_f()
%
% # Connections
% ##################################################
% self.connect((self.rtlsdr_source_0, 0), (self.throttle_0, 0))
% self.connect((self.throttle_0, 0), (self.stream_to_vector_0, 0))
% self.connect((self.stream_to_vector_0, 0), (self.fft_vxx_0, 0))
% self.connect((self.fft_vxx_0, 0), (self.complex_to_mag_squared_0, 0))
% self.connect((self.complex_to_mag_squared_0, 0), (self.sink, 0))
%
% if __name__ == '__main__':
% tb = top_block()
% tb.start()
% try:
% input('Press Enter to stop:')
% except EOFError:
% pass
% tb.stop()
% tb.wait()
% 	\end{python}
%\clearpage\newpage
% 
% QT GUI Frequency Sink (for spectrum visualization):\newline
%.-	Center Frequency: Match the center frequency of the Osmocom Source\newline
%.-	Bandwidth: Match the sample rate of the Osmocom Source
%\begin{python}
%# GNU FFT analyzer with spectrum visualization
% 
%import sys
%from gnuradio import gr, blocks, filter, analog
%from gnuradio import qtgui
%from gnuradio import osmosdr
%from gnuradio.qtgui import Range, RangeWidget
%from PyQt5 import Qt
%import sip
%
%class spectrum_analyzer(gr.top_block, Qt.QWidget):
% def __init__(self):
% # visualization
% ##################################################
% gr.top_block.__init__(self, "Spectrum Analyzer")
% Qt.QWidget.__init__(self)
% self.setWindowTitle("Spectrum Analyzer")
% qtgui.util.check_set_qss()
% self.top_scroll_layout = Qt.QVBoxLayout()
% self.setLayout(self.top_scroll_layout)
% self.top_scroll = Qt.QScrollArea()
% self.top_scroll.setFrameStyle(Qt.QFrame.NoFrame)
% self.top_scroll_layout.addWidget(self.top_scroll)
% self.top_scroll.setWidgetResizable(True)
% self.top_widget = Qt.QWidget()
% self.top_scroll.setWidget(self.top_widget)
% self.top_layout = Qt.QVBoxLayout(self.top_widget)
% self.top_grid_layout = Qt.QGridLayout()
% self.top_layout.addLayout(self.top_grid_layout)
% 
% self.settings = Qt.QSettings("GNU Radio", "spectrum_analyzer")
% 
% # Variables
% ##################################################
% self.samp_rate = 2e6
% self.center_freq = 100e6
%
% # Blocks
% ##################################################
% self.osmosdr_source = osmosdr.source(args="numchan=1 rtl=0")
% self.osmosdr_source.set_sample_rate(self.samp_rate)
% self.osmosdr_source.set_center_freq(self.center_freq, 0)
% self.osmosdr_source.set_freq_corr(0, 0)
% self.osmosdr_source.set_dc_offset_mode(0, 0)
% self.osmosdr_source.set_iq_balance_mode(0, 0)
% self.osmosdr_source.set_gain_mode(False, 0)
% self.osmosdr_source.set_gain(10, 0)
% self.osmosdr_source.set_if_gain(20, 0)
% self.osmosdr_source.set_bb_gain(20, 0)
% self.osmosdr_source.set_antenna("", 0)
% self.osmosdr_source.set_bandwidth(0, 0)
% 
% self.qtgui_freq_sink_x = qtgui.freq_sink_c(
% 1024, #size
% filter.firdes.WIN_BLACKMAN_hARRIS, #wintype
% self.center_freq, #fc
% self.samp_rate, #bw
% "", #name
% 1 #number of inputs
% )
% self.qtgui_freq_sink_x.set_update_time(0.10)
% self.qtgui_freq_sink_x.set_y_axis(-140, 10)
% self.qtgui_freq_sink_x.set_y_label('Relative Gain', 'dB')
% self.qtgui_freq_sink_x.set_trigger_mode(qtgui.TRIG_MODE_FREE, 0.0, 0, "")
% self.qtgui_freq_sink_x.enable_autoscale(False)
% self.qtgui_freq_sink_x.enable_grid(False)
% self.qtgui_freq_sink_x.set_fft_average(1.0)
% self.qtgui_freq_sink_x.enable_axis_labels(True)
% self.qtgui_freq_sink_x.enable_control_panel(False)
% 
% self._qtgui_freq_sink_x_win = sip.wrapinstance(self.qtgui_freq_sink_x.qwidget(), Qt.QWidget)
% self.top_layout.addWidget(self._qtgui_freq_sink_x_win)
% 
% self.connect((self.osmosdr_source, 0), (self.qtgui_freq_sink_x, 0))
% 
% if __name__ == '__main__':
% qapp = Qt.QApplication(sys.argv)
% tb = spectrum_analyzer()
% tb.start()
% tb.show()
% def quitting():
% tb.stop()
% tb.wait()
% qapp.connect(qapp, Qt.SIGNAL("aboutToQuit()"), quitting)
% qapp.exec_()
% \end{python}
% 
% [\checkmark] Spectrum-Analyzer
% 
%Git-hub spectrum-analyzer \href{https://github.com/topics/spectrum-analyzer?l=python}{$\gc{\bullet}$}\newline
%PyQtGraph based GUI for soapy power 
% \href{https://github.com/xmikos/qspectrumanalyzer}{$\gc{\bullet}$}\newline
%Fast Power Spectrum Sensing
% \href{https://github.com/xmikos/qspectrumanalyzer}{$\gc{\bullet}$}

%\clearpage\newpage
%\begin{enumerate}
%	\item \gc{VHF Frequency Scanning}
%
%1.	Osmocom Source: To interface with your RTL-SDR hardware.\newline
%2.	Frequency Sink: To visualize the frequency spectrum.\newline
%3.	Frequency Selector: To scan through different frequencies.
%\begin{python}
%#!/usr/bin/env python3
%# -*- coding: utf-8 -*-
%
%import sys
%from gnuradio import gr, blocks, analog, qtgui, osmosdr
%from PyQt5 import Qt
%import sip
%import numpy as np
%import time
%
%class vhf_scanner(gr.top_block, Qt.QWidget):
% def __init__(self):
% gr.top_block.__init__(self, "VHF Scanner")
% Qt.QWidget.__init__(self)
% self.setWindowTitle("VHF Scanner")
% qtgui.util.check_set_qss()
% self.top_scroll_layout = Qt.QVBoxLayout()
% self.setLayout(self.top_scroll_layout)
% self.top_scroll = Qt.QScrollArea()
% self.top_scroll.setFrameStyle(Qt.QFrame.NoFrame)
% self.top_scroll_layout.addWidget(self.top_scroll)
% self.top_scroll.setWidgetResizable(True)
% self.top_widget = Qt.QWidget()
% self.top_scroll.setWidget(self.top_widget)
% self.top_layout = Qt.QVBoxLayout(self.top_widget)
% self.top_grid_layout = Qt.QGridLayout()
% self.top_layout.addLayout(self.top_grid_layout)
%
% self.settings = Qt.QSettings("GNU Radio", "vhf_scanner")
%
% self.samp_rate = 2e6
% self.start_freq = 88e6
% self.stop_freq = 108e6
% self.step_freq = 1e6
% self.dwell_time = 1
% self.center_freq = self.start_freq
%
% # Blocks
% ###################
% # Osmocom Source
% ###################
% self.osmosdr_source = osmosdr.source(args="numchan=1 rtl=0")
% self.osmosdr_source.set_sample_rate(self.samp_rate)
% self.osmosdr_source.set_center_freq(self.center_freq, 0)
% self.osmosdr_source.set_freq_corr(0, 0)
% self.osmosdr_source.set_dc_offset_mode(0, 0)
% self.osmosdr_source.set_iq_balance_mode(0, 0)
% self.osmosdr_source.set_gain_mode(False, 0)
% self.osmosdr_source.set_gain(10, 0)
% self.osmosdr_source.set_if_gain(20, 0)
% self.osmosdr_source.set_bb_gain(20, 0)
% self.osmosdr_source.set_antenna("", 0)
% self.osmosdr_source.set_bandwidth(0, 0)
%
% self.throttle = blocks.throttle(gr.sizeof_gr_complex*1, self.samp_rate,True)
%
%
% # Frequency Sink
% ###################
% self.qtgui_freq_sink_x = qtgui.freq_sink_c(
% 1024, # FFT size
% qtgui.WIN_BLACKMAN_hARRIS, # Window function
% self.center_freq, # Center frequency
% self.samp_rate, # Sample rate
% "Frequency Spectrum", # Name
% 1 # Number of inputs
% )
% self.qtgui_freq_sink_x.set_update_time(0.10)
% self.qtgui_freq_sink_x.set_y_axis(-140, 10)
% self.qtgui_freq_sink_x.set_y_label('Relative Gain', 'dB')
% self.qtgui_freq_sink_x.enable_autoscale(False)
% self.qtgui_freq_sink_x.enable_grid(False)
% self.qtgui_freq_sink_x.set_fft_average(1.0)
% self.qtgui_freq_sink_x.enable_axis_labels(True)
% self.qtgui_freq_sink_x.enable_control_panel(False)
%
% self._qtgui_freq_sink_x_win = sip.wrapinstance(self.qtgui_freq_sink_x.qwidget(), Qt.QWidget)
% self.top_layout.addWidget(self._qtgui_freq_sink_x_win)
%
% # Connections
% self.connect((self.osmosdr_source, 0), (self.throttle, 0), (self.qtgui_freq_sink_x, 0))
%
% # Frequency Scanner Logic
% self.freq_scanner()
%
% def freq_scanner(self):
% import threading
% def scan():
% while True:
% for freq in np.arange(self.start_freq, self.stop_freq, self.step_freq):
% self.center_freq = freq
% self.osmosdr_source.set_center_freq(self.center_freq, 0)
% time.sleep(self.dwell_time)
% thread = threading.Thread(target=scan)
% thread.daemon = True
% thread.start()
%
%if __name__ == '__main__':
% qapp = Qt.QApplication(sys.argv)
% tb = vhf_scanner()
% tb.start()
% tb.show()
% def quitting():
% tb.stop()
% tb.wait()
% qapp.connect(qapp, Qt.SIGNAL("aboutToQuit()"), quitting)
% qapp.exec_()
%\end{python}
%
%[\checkmark] VHF scanning
%
%AM and NFM scanner with multiple equally spaced channels 
%\href{https://github.com/f4exb/sdrangel/blob/master/swagger/sdrangel/examples/scanner.py}{$\gc{\bullet}$}\newline
%GNU Radio Schematic Marine VHF Channel Scanner
%\href{https://jeremyclark.ca/wp/telecom/rtl-sdr-for-marine-vhf-scanner-on-gnu-radio/}{$\gc{\bullet}$}
%
%\clearpage\newpage
%Two-antenna diversity by selection diversity
%
%
%1.	Osmocom Source: To interface with your dual-channel SDR hardware.\newline
%2.	Complex to Magnitude Squared: To calculate the power of the signals from each antenna.\newline
%3.	Max Selector: To select the signal with the highest power. \newline
%4.	Frequency Sink: For visualizing the frequency spectrum of the selected signal.
%\newline
%5.	Stream Selector: To select the appropriate signal stream.
%
%\begin{python}
%#!/usr/bin/env python3
%# -*- coding: utf-8 -*-
%
%import sys
%from gnuradio import gr, blocks, analog, qtgui, osmosdr
%from PyQt5 import Qt
%import sip
%
%class max_selector(gr.sync_block):
%def __init__(self):
%gr.sync_block.__init__(self,
%name="max_selector",
%in_sig=[(gr.sizeof_gr_complex, 2)],
%out_sig=[gr.sizeof_gr_complex])
%
%def work(self, input_items, output_items):
%in0 = input_items[0][:, 0]
%in1 = input_items[0][:, 1]
%out = output_items[0]
%
%power0 = abs(in0) ** 2
%power1 = abs(in1) ** 2
%
%if power0.mean() > power1.mean():
%out[:] = in0
%else:
%out[:] = in1
%
%return len(output_items[0])
%
%class dual_channel_sdr(gr.top_block, Qt.QWidget):
%def __init__(self):
%gr.top_block.__init__(self, "Dual Channel SDR")
%Qt.QWidget.__init__(self)
%self.setWindowTitle("Dual Channel SDR")
%qtgui.util.check_set_qss()
%self.top_scroll_layout = Qt.QVBoxLayout()
%self.setLayout(self.top_scroll_layout)
%self.top_scroll = Qt.QScrollArea()
%self.top_scroll.setFrameStyle(Qt.QFrame.NoFrame)
%self.top_scroll_layout.addWidget(self.top_scroll)
%self.top_scroll.setWidgetResizable(True)
%self.top_widget = Qt.QWidget()
%self.top_scroll.setWidget(self.top_widget)
%self.top_layout = Qt.QVBoxLayout(self.top_widget)
%self.top_grid_layout = Qt.QGridLayout()
%self.top_layout.addLayout(self.top_grid_layout)
%
%self.settings = Qt.QSettings("GNU Radio", "dual_channel_sdr")
%
%self.samp_rate = 2e6
%self.center_freq = 100e6
%
%# Blocks
%self.osmosdr_source = osmosdr.source(args="numchan=2,rtl=0")
%self.osmosdr_source.set_sample_rate(self.samp_rate)
%self.osmosdr_source.set_center_freq(self.center_freq, 0)
%self.osmosdr_source.set_center_freq(self.center_freq, 1)
%self.osmosdr_source.set_freq_corr(0, 0)
%self.osmosdr_source.set_freq_corr(0, 1)
%self.osmosdr_source.set_dc_offset_mode(0, 0)
%self.osmosdr_source.set_dc_offset_mode(0, 1)
%self.osmosdr_source.set_iq_balance_mode(0, 0)
%self.osmosdr_source.set_iq_balance_mode(0, 1)
%self.osmosdr_source.set_gain_mode(False, 0)
%self.osmosdr_source.set_gain_mode(False, 1)
%self.osmosdr_source.set_gain(10, 0)
%self.osmosdr_source.set_gain(10, 1)
%self.osmosdr_source.set_if_gain(20, 0)
%self.osmosdr_source.set_if_gain(20, 1)
%self.osmosdr_source.set_bb_gain(20, 0)
%self.osmosdr_source.set_bb_gain(20, 1)
%self.osmosdr_source.set_antenna("", 0)
%self.osmosdr_source.set_antenna("", 1)
%self.osmosdr_source.set_bandwidth(0, 0)
%self.osmosdr_source.set_bandwidth(0, 1)
%
%self.complex_to_mag_sq_0 = blocks.complex_to_mag_squared(1)
%self.complex_to_mag_sq_1 = blocks.complex_to_mag_squared(1)
%
%self.max_selector = max_selector()
%
%self.qtgui_freq_sink_x_0 = qtgui.freq_sink_c(
%1024, # FFT size
%qtgui.WIN_BLACKMAN_hARRIS, # Window function
%self.center_freq, # Center frequency
%self.samp_rate, # Sample rate
%"Frequency Spectrum", # Name
%1 # Number of inputs
%)
%self.qtgui_freq_sink_x_0.set_update_time(0.10)
%self.qtgui_freq_sink_x_0.set_y_axis(-140, 10)
%self.qtgui_freq_sink_x_0.set_y_label('Relative Gain', 'dB')
%self.qtgui_freq_sink_x_0.enable_autoscale(False)
%self.qtgui_freq_sink_x_0.enable_grid(False)
%self.qtgui_freq_sink_x_0.set_fft_average(1.0)
%self.qtgui_freq_sink_x_0.enable_axis_labels(True)
%self.qtgui_freq_sink_x_0.enable_control_panel(False)
%
%self._qtgui_freq_sink_x_0_win = sip.wrapinstance(self.qtgui_freq_sink_x_0.qwidget(), Qt.QWidget)
%self.top_layout.addWidget(self._qtgui_freq_sink_x_0_win)
%
%# Connections
%self.connect((self.osmosdr_source, 0), (self.complex_to_mag_sq_0, 0))
%self.connect((self.osmosdr_source, 1), (self.complex_to_mag_sq_1, 0	
%\end{python}
%
%
%	 \begin{itemize}
%	\item[\checkmark] rtlsdr-scanner, software defined radio frequency scanner que utiliza un chip Realtek RTL2832u para convertir las senales de radio anal\'ogicas en digitales
%	\href{https://pypi.org/project/pyrtlsdr/}{$\gc{\checkmark}$} 
%	Jason \href{https://github.com/nootedandrooted/rtl-sdr-close-call-monitor}{$\gc{\bullet}$}
%	Raspberry Radio Scanner
%	\href{https://www.hackster.io/news/top-dng-builds-a-600-digital-radio-scanner-on-the-cheap-with-a-raspberry-pi-5-and-rtl-sdr-18209905583e#:~:text=Pseudonymous%20YouTuber%20%22Top%20DNG%22%20has,at%20a%20far%20lower%20cost.}{$\gc{\bullet}$}
%\end{itemize}
%
%\begin{figure}[!ht] 
%	\centering
%	{\resizebox{.72\columnwidth}{!}{\includegraphics{Figures/ANEV3.PNG}}} 
%	
%	\caption{Spectrum Monitoring Interface Design and System\href{https://ieeexplore.ieee.org/abstract/document/10366967}{$\rojo{\bullet}$}}
%\end{figure}
%\href{https://hackrf.readthedocs.io/en/latest/software_support.html}{$\gc{\bullet}$}. 
%\texttt{QSpectrumAnalyzer}\href{https://github.com/xmikos/qspectrumanalyzer}{$\gc{\bullet}$}.
%\texttt{gqrx}\href{https://www.gqrx.dk/}{$\gc{\bullet}$}
%%%%%%%%%%%%%%%%%%%%%%%
%\section{Spectrum~Sensing}
%\begin{Tasks}{\Large
%		\begin{list}{\checkmark}{}
%			%\item[*] Spectrum Monitoring
%			\item Signal Detection /
%			
%			\item Signal Classification
%			
%			\item Channel-State Estimation
%			
%			\item Decision Making
%			
%			\item Monitoring and System Management
%		\end{list}
%	}
%\end{Tasks}
%
%\subsection{Signal~Detection}
%\begin{Example}{1.8}{
%		\begin{itemize}
%			\item Data Collection and Assembly:
%			\begin{itemize}
%				\item Signal Reception Arrangement
%				\item Sampling and ADC Conversion
%				\item Data Storage
%			\end{itemize}
%			\bigskip
%			\item Signal Conditioning
%			\begin{itemize}
%				\item Data cleaning and anomaly detection
%				\item Narrowband Filtering and demodulation
%				\item Wideband Signal Decimation		
%			\end{itemize} 
%		\end{itemize}
%	}{SDR~Framework}
%\end{Example}
%
%\begin{Example}{1.8}{
%		\begin{itemize}
%			\item Energy calculation
%			\begin{itemize}
%				\item Power Estimation and frequency scanning
%				\item Noise (SNR) Estimation 
%				\item Thresholding 
%			\end{itemize}
%		\end{itemize}
%	}
%	{Machine-Learning~Framework}
%\end{Example}
%\bigskip
%Literature:
%\begin{enumerate}
%	\item A review of spectrum sensing in modern cognitive radio networks
%	\href{https://link.springer.com/article/10.1007/s11235-023-01079-1}{$\gc{\bullet}$}
%	\item Spectrum sensing in cognitive radio: A deep learning based model
%	\href{https://onlinelibrary.wiley.com/doi/abs/10.1002/ett.4388?casa_token=CSLpGNx3jF4AAAAA:RMlcZhrFsz1ExBd-mnxjWJFFy1TQ7ykGc3DPYSSZK-_5jn1RpzcOzU133pz8_AVolI3-EWh5Z6g2zh0}{$\gc{\bullet}$}
%	\item 
%	A Review of Spectrum Sensing Techniques Based on Machine Learning
%	\href{https://www.igi-global.com/pdf.aspx?tid=322771&ptid=307143&ctid=4&oa=true&isxn=9781668473665}{$\gc{\bullet}$}
%	\item 
%	Deep Neural Networks for Spectrum Sensing: A Review
%	\href{https://ieeexplore.ieee.org/abstract/document/10217791}{$\gc{\bullet}$}
%	
%	\item Spectrum Sensing Techniques in Cognitive Radio Networks: A Survey
%	\href{https://d1wqtxts1xzle7.cloudfront.net/116019700/3211ijngn03-libre.pdf?1718459109=&response-content-disposition=inline%3B+filename%3DSpectrum_Sensing_Techniques_in_Cognitive.pdf&Expires=1722656421&Signature=eBnkAbvBs1KyWzawZT3a9e~7p3FebNLytmDL-y2s95SLxQzzt5rvsbfWuq05Wz7V~5u0yelX88TM4PvmJ1Z9OlUKMVx2IvIntzaDn1RV8sQd~qlBduCenpzTObcomRkQYkORKqziAY2qFviFwptV9i1riZWKM4gTZkgKi2JWfdXjqDTQ7gT1Y6AW0Wynq2fCZ3zFgceEP5RmmS2ICMKY8HZeF9-IZjiJESJQDzveRl9vqjO6SxQuZIKxFYBBE2tXz1YAIOgbHeuxHx2Z6HQ00MfGnRyrBPY3Gl3HtC0iCYM5TKCCAfWmxntkw6LhXeFDtMANgl5ZEN5gewpAiPjL3Q__&Key-Pair-Id=APKAJLOHF5GGSLRBV4ZA}{$\gc{\bullet}$}
%\end{enumerate}
%\clearpage\newpage
%\subsubsection{Data Collection and Assembly}
%%Acquisition, down/sampling, storage, and preparation of sample sets holding primary information.
%\bigskip
%\begin{itemize}
%	\item \textsl{Enhanced signal reception} 
%	\begin{itemize}
%		\item
%		Diversity Antennas for reducing the impact of fading and shadowing: spatial diversity (using multiple antennas at different locations), polarization diversity (antennas with different polarization orientations), frequency diversity, and pattern diversity (antennas with different radiation patterns).
%		\item 
%		Enhanced Detection Sensitivity: By combining signals from multiple antennas, diversity combining techniques such as selection diversity, maximal ratio combining (MRC), or equal gain combining (EGC) can be employed to improve the detection sensitivity of spectrum sensing.
%		\item 
%		Multisensor Sensor Synchronization. Implementing diversity antennas adds complexity to the cognitive radio system, including hardware requirements and signal processing algorithms.
%		
%		Literature:
%		
%		\begin{itemize}
%			\item
%			Exploiting Space and Antenna Diversity for Wideband Spectrum Sensing
%			\href{https://ieeexplore.ieee.org/abstract/document/9352919}{$\gc{\bullet}$}
%			\item 
%			Energy Detector and Diversity Techniques for Cooperative Spectrum Sensing
%			\href{https://link.springer.com/chapter/10.1007/978-981-16-8554-5_17}{$\gc{\bullet}$}
%			\item 
%			Multiple antenna spectrum sensing
%			\href{https://ieeexplore.ieee.org/abstract/document/5403561?casa_token=nGjY8wWhb2IAAAAA:NhCQEmYkC0HPAfOVqzDrPvrIhgNuQZgRc04q3eVnf9vOEa2QMeiKfO9oqhTFo9gj0zR_V2GUqf4}{$\gc{\bullet}$}
%			\item 
%			Multi-antenna receiver based on maximum-likelihood 
%			\href{https://ieeexplore.ieee.org/abstract/document/10250901}{$\gc{\bullet}$} 
%			\item SS Scheme for a Multi-Antenna Receiver
%			\href{https://ieeexplore.ieee.org/abstract/document/10056401}{$\gc{\bullet}$}
%			\item 
%			Deep Learning-Based Spectrum Sensing Scheme for a Multi-Antenna Receiver	\href{https://ieeexplore.ieee.org/abstract/document/10056401}{$\gc{\bullet}$}
%			
%		\end{itemize}
%		\bigskip
%		\item Sampling and ADC conversion 
%	\end{itemize}	
%	\begin{itemize}
%		\item Narrow-band sampling: 
%		
%		\begin{itemize}
%			\item Nyquist-based, wavelet-based, 
%			
%			\item Oversampling with enhanced resolution.
%			
%		\end{itemize}
%		\item Wide-band sampling: 
%		
%		Literature:
%		\item 
%		Recent Advances on Sub-Nyquist Sampling-Based Wideband Spectrum Sensing
%		\href{https://ieeexplore.ieee.org/abstract/document/9448009}{$\gc{\bullet}$}
%		
%		\item Machine Learning Empowered Spectrum Sensing Under a Sub-Sampling Framework
%		\href{https://ieeexplore.ieee.org/abstract/document/9756217}{$\gc{\bullet}$}
%		
%		\item
%		Random sampling for effective spectrum sensing in cognitive radio time slotted environment
%		\href{https://www.sciencedirect.com/science/article/abs/pii/S1874490721002196}{$\gc{\bullet}$}
%		\item Multiantenna-Assisted Wideband Spectrum Sensing Based on Sub-Nyquist Sampling
%		\href{https://ieeexplore.ieee.org/abstract/document/9292941}{$\gc{\bullet}$}
%		\item
%		Wideband Spectrum Sensing using Sub-Nyquist Sampling Approaches
%		\href{https://ieeexplore.ieee.org/abstract/document/9221076}{$\gc{\bullet}$}
%		\item
%		Sub-Nyquist Sampling-Based Wideband Spectrum Sensing
%		\href{https://arxiv.org/abs/2105.03029}{$\gc{\bullet}$}
%		\item
%		A compressed power spectrum estimation approach
%		\href{https://link.springer.com/article/10.1007/s11704-022-2158-6
%		}{$\gc{\bullet}$}
%		\item 
%		Sub-Nyquist sampling-based wideband spectrum sensing: a compressed power spectrum estimation approach
%		\href{https://link.springer.com/article/10.1007/s11704-022-2158-6}{$\gc{\bullet}$}
%		
%		%\item Data Storage
%		%\begin{itemize}
%		%\item Real-time analysis / Off-line training and validation
%		%	
%		%\item 
%		%Data Retention Policies dictated by regulatory requirements, operational needs, or privacy considerations.
%		%	/
%		%Data anonymization or encryption to protect sensitive information and ensure compliance with privacy regulations.
%		%	
%		%\item 
%		%Data storage infrastructure for spectrum sensing applications may include local storage on cognitive radio devices, networked storage systems, or cloud-based storage solutions.
%	\end{itemize}
%\end{itemize}
%\clearpage\newpage
%
%\subsubsection{Signal Conditioning}
%\begin{itemize}
%	
%	\item Narrow-band Filtering and demodulation
%	\begin{itemize}
%		\item Narrow-band band pass and adaptive filtering to isolate specific signals or frequency bands of interest while suppressing noise and interference, improving the signal-to-noise ratio (SNR).
%		
%		\item Demodulation involves extracting the original information carried by modulated signals, such as voice, data, or multimedia content.
%	\end{itemize}
%	\item Wideband Signal Decimation
%	\begin{itemize}
%		\item Channelization, filter banks, and multichannel sensing
%		
%		\item Software-defined filters: Filtering implementation on software-defined radio (SDR) platforms (processing power, flexibility, cost, and power consumption).
%	\end{itemize}
%\end{itemize}
%
%\subsubsection{Energy Detection}
%\begin{itemize}
%	\item Narrowband Estimation
%	\href{https://www.hindawi.com/journals/wcmc/2022/3933336/}{$\rojo{\bullet}$}
%	\begin{itemize}
%		\item Energy Detection ($L_2$-based estimation) and Entropy-based detection
%		
%		\item Shape signal Detection : correlation, cyclostationarity, covariance, waveform-based
%		\item Matched Filter ($L_2$-based filtering)
%		\item Matrix decomposition-based (eigenvalue detection)
%		
%		Detection tutorial
%		\href{https://jcis.sbrt.org.br/jcis/article/view/811/534}{$\rojo{\bullet}$}
%		Energy detection-based spectrum sensing machine
%		\href{https://link.springer.com/chapter/10.1007/978-981-99-2710-4_24}{$\rojo{\bullet}$}
%		Maximizing Eigenvalue Using Machine Learning
%		\href{https://www.ijisae.org/index.php/IJISAE/article/view/3654}{$\rojo{\bullet}$}
%		Energy detection under noise power
%		\href{https://www.sciencedirect.com/science/article/pii/S1110016822008018}{$\rojo{\bullet}$} 
%		\href{https://ieeexplore.ieee.org/abstract/document/10112923?casa_token=jIMGBzDKxycAAAAA:ghWqKpxK44z0lQNQuqRjHSidGwS2bzb-ddNdFOMXNaL7_iFaxtcDpCC9JegQA_KskCfX2uutuoQ}{$\rojo{\bullet}$} 
%		Multiscale Wavelet Extremum Detection With the Spectrum Energy Detection
%		\href{https://ieeexplore.ieee.org/abstract/document/10238706}{$\rojo{\bullet}$}
%		Complex Rao Detector
%		\href{https://ieeexplore.ieee.org/abstract/document/8546773?casa_token=nxpgRXbmB-wAAAAA:seTALFId3iEkbftTO1LaMb0O6EHeLiteV_L9uMJ8JSu_7zAjqmwZIZ6qVJSN48WUGffeCP2FVhc}{$\rojo{\bullet}$}
%		LSTM detector
%		\href{https://www.mdpi.com/1424-8220/22/6/2286}{$\rojo{\bullet}$}
%		
%		DL-based Signal detection
%		\href{https://ieeexplore.ieee.org/abstract/document/10286309?casa_token=iL6FIEZE_48AAAAA:fdGco0glbWCcGRjTOhDuop0AWaO0KHegWCvOO0p-BkDFlNdggYMh88JVNxhrdoudH0_4HIHy8Ms}{$\rojo{\bullet}$}
%		Exploring DL for Adaptive Energy Detection Threshold Determination: A Multistage Approach
%		\href{https://www.mdpi.com/2079-9292/12/19/4183}{$\rojo{\bullet}$}Deep Learning for Adaptive Energy Detection Threshold
%		\href{https://www.mdpi.com/2079-9292/12/19/4183}{$\rojo{\bullet}$}
%	\end{itemize}
%	\item Wideband Estimation
%	\href{https://ieeexplore.ieee.org/abstract/document/9448009?casa_token=LkPdmTYO0agAAAAA:ZUProkXoXB7ShCxYTV5AxF1kUHtHGfsTFMECt9qX089q1HKmqHpZS21oJtkwWr7H6jvhFOktELU}{$\rojo{\bullet}$}
%	\begin{itemize}
%		\item Sub-Nyquist sampling-based wideband SS
%		\href{https://link.springer.com/article/10.1007/s11704-022-2158-6}{$\rojo{\bullet}$}
%		. Wavelet-based, 
%		\item Filter-bank, and Multiple narrow bands
%		
%		Sub-Nyquist Sampling-Based Wideband Spectrum Sensing
%		\href{https://ieeexplore.ieee.org/abstract/document/9448009?casa_token=l9cvomcPDyIAAAAA:zVfroh7X4DDjoDgjdx4HMq8bZdL2B59ZLTMt-Guw5J47x9SlLkABHO0w5cX9qQ_r61CO2sKUTjM}{$\rojo{\bullet}$}
%	\end{itemize}
%	\item Detection Performance Metrics:
%	
%	Detection Probability, missed detection probability, False Alarm Probability, and Receiver operating characteristics curves. Signal to Noise ratio (SNR). 
%	Evaluating the practical performance of energy detector based spectrum sensing for cognitive radio
%	\href{https://pubs.aip.org/aip/acp/article-abstract/2787/1/050007/2902495/Evaluating-the-practical-performance-of-energy?redirectedFrom=fulltext}{$\rojo{\bullet}$}
%	\item Cooperative cognitive radio networks 
%	
%	Unwanted interference because of multipath fading and shadowing effects makes undetectable actual PU transmission (hidden-node problem).
%\end{itemize}
%
%\clearpage\newpage
%
%%%\begin{python}
%%%# GNU Radio flowgraph for FM SNR measurement
%%%from gnuradio import gr, blocks, analog, filter, qtgui
%%%
%%%class fm_snr_example(gr.top_block):
%%% def __init__(self):
%%% gr.top_block.__init__(self, "FM SNR Example")
%%% 
%%% # Parameters
%%% samp_rate = 1e6
%%% freq = 100e6
%%% noise_voltage = 0.1
%%% 
%%% # Blocks
%%% self.src = analog.sig_source_c(samp_rate, analog.GR_COS_WAVE, freq, 1)
%%% self.noise = analog.noise_source_c(analog.GR_GAUSSIAN, noise_voltage)
%%% self.adder = blocks.add_vcc()
%%% self.fm_demod = analog.wfm_rcv(pll_freq_max=5000, pll_freq_min=-5000)
%%% self.fft = qtgui.freq_sink_f(1024, firdes.WIN_HAMMING, 0, samp_rate, "FFT Plot", 1)
%%% 
%%% # Connections
%%% self.connect(self.src, (self.adder, 0))
%%% self.connect(self.noise, (self.adder, 1))
%%% self.connect(self.adder, self.fm_demod)
%%% self.connect(self.fm_demod, self.fft)
%%%
%%%if __name__ == '__main__':
%%% tb = fm_snr_example()
%%% tb.start()
%%% tb.wait()
%%%
%%%\end{python}
%%\begin{python}
%%from gnuradio import gr
%%from gnuradio import blocks
%%from gnuradio import analog
%%from gnuradio import filter
%%from gnuradio import audio
%%from gnuradio import qtgui
%%
%%class fm_snr_example(gr.top_block):
%%
%% def __init__(self):
%% gr.top_block.__init__(self, "FM SNR Example")
%%
%% # Parameters
%% samp_rate = 2e6
%% center_freq = 100e6 # Example FM station frequency
%% audio_rate = 48e3
%%
%% # Blocks
%% self.src = osmosdr.source(args="numchan=1")
%% self.src.set_sample_rate(samp_rate)
%% self.src.set_center_freq(center_freq)
%% self.src.set_gain(30)
%%
%% self.chan_filt = filter.freq_xlating_fir_filter_ccf(1, (1,), 0, samp_rate)
%%
%% self.fm_demod = analog.wfm_rcv(quad_rate=samp_rate, audio_decimation=10)
%% 
%% self.audio_sink = audio.sink(int(audio_rate), '', True)
%%
%% self.throttle = blocks.throttle(gr.sizeof_gr_complex*1, samp_rate, True)
%% 
%% self.probe_signal = blocks.probe_signal_f()
%%
%% # Connections
%% self.connect(self.src, self.chan_filt, self.fm_demod, self.audio_sink)
%% self.connect(self.fm_demod, self.probe_signal)
%%
%% def get_snr(self):
%% signal_power = self.probe_signal.level()
%% noise_power = 1 # Placeholder, actual noise calculation needed
%% snr = 10 * log10(signal_power / noise_power)
%% return snr
%%
%%if __name__ == '__main__':
%% tb = fm_snr_example()
%% tb.start()
%% tb.wait()
%% print("SNR:", tb.get_snr())
%%
%%\end{python}
%% 
%%\item \gc{Detecci\'on de canal}
%%
%%Valor reportado: presencia -- 1 , ausencia -- 0 por canal
%%
%%\emph{Procedimiento asociado}: Threshold Energy Detection
%% \begin{itemize}
%%\item 
%%Energy detection-based spectrum sensing machine
%%\href{https://link.springer.com/chapter/10.1007/978-981-99-2710-4_24}{$\gc{\bullet}$}
%%\item Practical Implementation of Adaptive Threshold Energy Detection using Software Defined Radio
%%\href{https://ieeexplore.ieee.org/abstract/document/9268104}{$\gc{\bullet}$} 
%%
%%\end{itemize}
%%
%%Steps for Threshold Energy Detection:
%%\begin{itemize}
%%\item 
%%Capture the Signal: Use an SDR to capture the FM signal.
%%\item 
%%Calculate Signal Energy: Compute the energy of the received signal over a given period.
%%\item 
%%Set Threshold: Define a threshold value based on the noise floor or a specific requirement.
%%\item 
%%Comparison: Compare the calculated energy to the threshold.
%%\item 
%%Decision: If the energy exceeds the threshold, detect the signal; otherwise, treat it as noise.
%%\end{itemize}
%%
%%\begin{python}
%%from gnuradio import gr, blocks, analog, filter
%%import numpy as np
%%
%%class threshold_energy_detection(gr.top_block):
%% def __init__(self):
%% gr.top_block.__init__(self, "Threshold Energy Detection")
%%
%% # Parameters
%% samp_rate = 2e6
%% center_freq = 100e6
%% threshold = 0.5 # Example threshold
%%
%% # Blocks
%% self.src = osmosdr.source(args="numchan=1")
%% self.src.set_sample_rate(samp_rate)
%% self.src.set_center_freq(center_freq)
%% self.src.set_gain(30)
%%
%% self.chan_filt = filter.freq_xlating_fir_filter_ccf(1, (1,), 0, samp_rate)
%% self.fm_demod = analog.wfm_rcv(quad_rate=samp_rate, audio_decimation=10)
%% self.probe_signal = blocks.probe_signal_f()
%%
%% # Connections
%% self.connect(self.src, self.chan_filt, self.fm_demod, self.probe_signal)
%%
%% def detect_signal(self):
%% signal_energy = self.probe_signal.level()
%% if signal_energy > threshold:
%% print("Signal Detected")
%% else:
%% print("No Signal Detected")
%%
%%if __name__ == '__main__':
%% tb = threshold_energy_detection()
%% tb.start()
%% tb.wait()
%% tb.detect_signal()
%%
%%\end{python}
%%\end{list}
%%\clearpage\newpage
%%
%%\subsubsection{SERVICIO Fijo y M\'ovil}
%%rango de frecuencia: 137 MHz - 144 MHz, ancho de canal ? MHz, tiempo de observaci\'on [? min] periodicidad de medida [cada ?? min], espacialidad [Manizales, Bogot\'a, ???]
%%
%%\paragraph{Par\'ametros}
%%
%%\begin{list}{.-}{}
%%\item \gc{Potencia}: 
%%
%%\emph{Procedimiento asociado}: {Narrowband Frequency Scanning}
%%
%%\item \gc{Signal-to-Noise ratio -- S/N }: 
%%
%%\emph{Procedimiento asociado}: {Narrowband Frequency Scanning}
%%\begin{itemize}
%%	\item Radio Frequency Detailed Scan from 240 to 960 MHz 
%%	\href{https://rfds.tilda.ws/}{$\gc{\bullet}$}
%%\href{https://people.skolelinux.org/pere/blog/rtlsdr_scanner__software_defined_radio_frequency_scanner_for_Linux____nice_free_software.html}{$\gc{\bullet}$}
%%	\href{https://sourceforge.net/projects/rtlsdrscanner/}{$\gc{\bullet}$}
%%
%%Valor reportado: presencia -- 1 , ausencia -- 0 por canal
%%\end{itemize}
%%
%%Valores reportados: S/N Max, S/N min, S/N media por canal
%%
%%\item \gc{Detecci\'on de canal}
%%
%%\emph{Procedimiento asociado}: Adaptive Threshold Energy Detection
%%\begin{itemize}
%%	\item Practical Implementation of Adaptive Threshold Energy Detection using Software Defined Radio
%%\href{https://ieeexplore.ieee.org/abstract/document/9268104}{$\gc{\bullet}$} 
%%
%%\end{itemize}
%%
%%Valor reportado: presencia -- 1 , ausencia -- 0 por canal
%%
%%\end{list}
%%\clearpage\newpage
%% 
%%\subsection*{Wideband Scanning }
%%\begin{itemize}
%%	\item Detailed Bluetooth LE Scanner with Python
%%	\href{https://medium.com/@protobioengineering/how-to-make-a-detailed-bluetooth-le-scanner-with-a-macbook-and-python-8e2c7dccfd39}{$\gc{\bullet}$}
%%	\item IoT-Scan: Network Reconnaissance for the Internet of Things
%%	\href{https://ieeexplore.ieee.org/abstract/document/10299538}{$\gc{\bullet}$}
%%	
%%	Snout: A Middleware Platform for Software-Defined Radios
%%	\href{https://ieeexplore.ieee.org/abstract/document/9925108}{$\gc{\bullet}$}
%%	
%%	LoRadar: An Efficient LoRa Channel Occupancy Acquirer based on Cross-channel Scanning
%%	\href{https://ieeexplore.ieee.org/abstract/document/9796845}{$\gc{\bullet}$}
%%	\item PytonDAQ
%%		\href{https://iopscience.iop.org/article/10.1088/1742-6596/2511/1/012016/pdf}{$\gc{\bullet}$}
%%	\item Radio Frequency Density Sensor to count mobile devices within a range
%%\href{https://forums.raspberrypi.com/viewtopic.php?t=350821}{$\gc{\bullet}$}
%%
%%For analyzing the transmission protocols
%%\href{https://ieeexplore.ieee.org/abstract/document/9731450}{$\gc{\bullet}$}
%%\item Real-time Decoding of Satellite Signals
%%\href{https://ieeexplore.ieee.org/abstract/document/1012677}{$\gc{\bullet}$}
%%\item identification of open and closed channels	
%%\href{https://pubs.gnuradio.org/index.php/grcon/article/view/110}{$\gc{\bullet}$}
%%
%%\item Drone Detection and Defense Systems: Survey and a Software-Defined Radio-Based Solution
%%\href{https://www.mdpi.com/1424-8220/22/4/1453}{$\gc{\bullet}$}
%%\end{itemize}
%%\clearpage\newpage
%%\section*{Informe}
%%\begin{center}\date(\today)\end{center}
%%\subsection{Signal~Detection}
%%\begin{Example}{1.8}{
%%\begin{itemize}
%%	\item Data Collection and Assembly:
%%	\begin{itemize}
%%		\item Signal Reception Arrangement
%%		\item[ \checkmark ] Sampling and ADC Conversion
%%		\item Data Storage
%%	\end{itemize}
%%	\bigskip
%%	\item Signal Conditioning
%%	\begin{itemize}
%%		\item Data cleaning and anomaly detection
%%		\item[ \checkmark ] Narrowband Filtering and demodulation
%%		\item Wideband Signal Decimation		
%%	\end{itemize} 
%%\end{itemize}
%%}{Hardware Framework}
%%\end{Example}
%%
%%\begin{Example}{1.8}{
%%\begin{itemize}
%%\item Energy calculation
%%\begin{itemize}
%%	\item Power Estimation and frequency scanning
%%	\item Noise (SNR) Estimation 
%%	\item Thresholding 
%%\end{itemize}
%%\end{itemize}
%%}
%%{Data Analysis}
%%\end{Example}
%%\subparagraph{Sampling and ADC conversion}
%%	
%%	\begin{itemize}
%%	\item Narrow-band sampling: 
%%	
%%	\begin{itemize}
%%	\item Nyquist-based, wavelet-based, 
%%	
%%	\item Oversampling with enhanced resolution
%%	\end{itemize}
%%	
%%	\item Wide-band sampling: 
%%	\begin{itemize}
%%	\item Compressive sampling (decimation), multicoset sampling
%%	
%%	%\item Data Compression and Undersampling to feed NN estimators: sigma-delta modulation
%%	\end{itemize}
%%	\end{itemize}
%%	
%%\subparagraph{Signal Conditioning}
%%\begin{itemize}
%%
%%	\item Narrow-band Filtering and demodulation
%%	\begin{itemize}
%%	\item Narrow-band band pass and adaptive filtering to isolate specific signals or frequency bands of interest while suppressing noise and interference, improving the signal-to-noise ratio (SNR) of the desired signals.
%%	
%%	\item Demodulation involves extracting the original information carried by modulated signals, such as voice, data, or multimedia content.
%%	\end{itemize}
%%	\item Wideband Signal Decimation
%%	\begin{itemize}
%%	\item Channelization, filter banks, and multichannel sensing
%%	
%%	\item Software-defined filters: Filtering implementation on software-defined radio (SDR) platforms (processing power, flexibility, cost, and power consumption).
%%	\end{itemize}
%%\end{itemize}
%%
%%\subparagraph{Energy Calculation}
%%
%%\begin{itemize}
%%\item{Narrowband Frequency Scanning}
%%\begin{itemize}
%%	%\item Preliminary Design of the Laboratory Stand for Remote and Subsurface Sensing
%%	%	\href{https://ieeexplore.ieee.org/abstract/document/10380333}{$\gc{\bullet}$}
%%	\item spectrum-analyzer
%%	\href{https://github.com/topics/spectrum-analyzer?l=python}{$\gc{\bullet}$}
%%	\href{https://github.com/xmikos/qspectrumanalyzer}{$\gc{\bullet}$}	
%%	\item Simple AM and NFM scanner with multiple equally spaced channels 
%%	\href{https://github.com/f4exb/sdrangel/blob/master/swagger/sdrangel/examples/scanner.py}{$\gc{\bullet}$}
%%	GNU Radio Schematic Marine VHF Channel Scanner
%%\href{https://jeremyclark.ca/wp/telecom/rtl-sdr-for-marine-vhf-scanner-on-gnu-radio/}{$\gc{\bullet}$}
%%	
%%	\item rtlsdr-scanner, software defined radio frequency scanner que utiliza un chip Realtek RTL2832u para convertir las senales de radio anal\'ogicas en digitales
%%	\href{https://pypi.org/project/pyrtlsdr/}{$\gc{\checkmark}$} 
%%	Jason \href{https://github.com/nootedandrooted/rtl-sdr-close-call-monitor}{$\gc{\bullet}$}
%%
%%	\item 	Raspberry Radio Scanner
%%	\href{https://www.hackster.io/news/top-dng-builds-a-600-digital-radio-scanner-on-the-cheap-with-a-raspberry-pi-5-and-rtl-sdr-18209905583e#:~:text=Pseudonymous%20YouTuber%20%22Top%20DNG%22%20has,at%20a%20far%20lower%20cost.}{$\gc{\bullet}$}
%%\end{itemize}
%%	\item Narrowband Estimation
%%	\begin{itemize}
%%		\item Energy Detection ($L_2$-based estimation) and Entropy-based detection
%%		
%%		Energy detection-based spectrum sensing machine
%%		\href{https://link.springer.com/chapter/10.1007/978-981-99-2710-4_24}{$\gc{\bullet}$}
%%		\item Shape signal Detection : correlation, cyclostationarity, covariance, waveform-based
%%		\item Matched Filter ($L_2$-based filtering)
%%		\item Matrix decomposition-based (eigenvalue detection)
%%		
%%		Maximizing Eigenvalue Using Machine Learning
%%		\href{https://www.ijisae.org/index.php/IJISAE/article/view/3654}{$\gc{\bullet}$}
%%		
%%		FlashFFTConv \href{https://medium.com/@multiplatform.ai/stanford-researchers-introduced-flashfftconv-to-optimize-fft-convolutions-for-long-sequences-in-3ce8706517a8}{$\gc{\bullet}$}
%%		
%%		 Energy detection under noise power
%%		\href{https://www.sciencedirect.com/science/article/pii/S1110016822008018}{$\gc{\bullet}$} 
%%		
%%		Multiscale Wavelet Transform Extremum Detection With the Spectrum Energy Detection
%%		\href{https://ieeexplore.ieee.org/abstract/document/10238706}{$\gc{\bullet}$}
%%		
%%		Exploring DL for Adaptive Energy Detection Threshold Determination: A Multistage Approach
%%		\href{https://www.mdpi.com/2079-9292/12/19/4183}{$\gc{\bullet}$}Deep Learning for Adaptive Energy Detection Threshold
%%		\href{https://www.mdpi.com/2079-9292/12/19/4183}{$\gc{\bullet}$}
%%\end{itemize}
%%\item Wideband Estimation
%%	\begin{itemize}
%%	\item Nyquist-based. Wavelet-based, 
%%	\item Filter-bank, and Multiple narrow bands
%%\end{itemize}
%%\item Detection Performance Metrics:
%%
%% Detection Probability, missed detection probability, False Alarm Probability, and Receiver operating characteristics curves. Signal to Noise ratio (SNR). 
%% Evaluating the practical performance of energy detector based spectrum sensing for cognitive radio
%% \href{https://pubs.aip.org/aip/acp/article-abstract/2787/1/050007/2902495/Evaluating-the-practical-performance-of-energy?redirectedFrom=fulltext}{$\gc{\bullet}$}
%% 
%%\end{itemize}
%%%\clearpage\newpage
%%%\section{Machine Learning Framework}
%%%
%%%\begin{DefQuot}{2.1}
%%%{The \emph{Data Analytic Pipeline} automates machine learning workflows by processing and integrating data sets into a model to be evaluated and delivered, providing flexibility, efficiency, and better management in the framework implementation.}
%%%\end{DefQuot}
%%%
%%%\begin{figure}[!ht]
%%%	\centering
%%%	\resizebox{\columnwidth}{!}{\includegraphics{Figures/data_analytics_stages.png} }
%%%	\caption{Main Architecture}
%%%\end{figure}
%%%\bigskip
%%%\begin{itemize}
%%%	\item
%%%	\emph{Data Collection \& Assembly} 
%%%	
%%%Acquisition, down/sampling, storage, and preparation of sample sets holding primary information about the inferring task under modeling.
%%%	% data collection (dataset creation)
%%%	% data exploration (understand the data)	
%%%	\item
%%%	\emph{Data Preprocessing}
%%%	
%%%	Inconsistent data is cleaning, transformed or encoded to be adequately parsed and fed into the compilation chain at a real computation burden.
%%%	\item
%%%	\emph{Model Building/Training}
%%%	
%%%	Selection/design of an appropriate machine learning algorithm for model training that specifies how to infer patterns in data.
%%%	\item 
%%%	\emph{Model Evaluation}
%%%	
%%%	The models are trained and tested on sample data sets to make predictions and choose the best-performing model.
%%%	\item 
%%%	\emph{Model Deployment}
%%%	
%%%	The machine learning model is deployed to the production line to obtain predictions based on real-time data.
%%%\end{itemize}
%%%
%%%%\clearpage\newpage
%%%%\subsection*{Data Preprocessing:} 
%%%%
%%%%%feature extraction, feature selection, dimensionality reduction, sampling
%%%%
%%%%\begin{itemize} 
%%%%	\item[--] Formatting and Cleaning Data 
%%%%	\item[--] Data Augmentation and Stratification 
%%%%	\item[--] Feature Engineering and Data Transformation:
%%%%\end{itemize}
%%%%\medskip
%%%%%\hypersetup{hidelinks}
%%%%
%%%%[$\checkmark$]\textsl{Formatting Data }
%%%%\begin{itemize}
%%%%		
%%%%	\item Data Visualization\href{https://pub.towardsai.net/time-series-data-visualization-in-python-2b1959726312}{$\gc{\bullet}$}
%%%%	
%%%%	\item {Anomaly Detection:}
%%%%	
%%%%	\item {Missing Values and Imputation}
%%%%	
%%%%	\item {Statistical test on data}
%%%%	
%%%%	\item {Data Augmentation and Stratification}
%%%%\end{itemize}
%%%%
%%%%[$\checkmark$]\textsl{Feature Engineering and Data Transformation}
%%%%
%%%%\begin{itemize}
%%%%	\item Time Series Transformation and Feature Selection: 
%%%%	\item {Latent Variable Decomposition}
%%%%
%%%%\end{itemize}
%%%
%%%\clearpage\newpage
%%%\subsection*{Model Building/Training:} 
%%%
%%%[$\checkmark$] \textsl{DL Model Design }
%%%	\begin{DefQuot}{1.2}
%%%	{
%%%\begin{itemize}
%%%	\item[--] \textsl{Task}: Scanning of VHF/UHF frequencies
%%%	\item[--] \textsl{Inference}: Prediction of power spectral density 
%%%\end{itemize}
%%%}
%%%\end{DefQuot}
%%%
%%%\begin{figure}[!ht]
%%%	\centering
%%%	\resizebox{\columnwidth}{!}{\includegraphics[trim={0 19.1cm 0 0},clip]{Figures/MLScheme} }
%%%	\caption{DL Model Architecture}
%%%\end{figure}
%%%
%%%\begin{list}{--}{}
%%%
%%%\item \textsl{Multivariate Input Data}: Raw time-series data captured after IF mixer sampled at $22$\,\textit{Msps} 
%%%
%%%\item \textsl{Validation requirements}: 
%%%
%%%strategy
%%%
%%%sequencing
%%%
%%%\item \textsl{NN models}: 
%%%\begin{description}
%%%	\item[MLP] 
%%%	\item[LSTM] 
%%%	\item[VAE] 
%%%\end{description}
%%%
%%%\clearpage\newpage
%%%\item \textsl{Optimization of NN Models}: \gc{Speeding up vs performance scoring}
%%%
%%%Model Optimization frameworks
%%%\begin{itemize}
%%%	\item RandomSearch, Optimizacion Space:
%%%	\item ?, Optimizacion Space:
%%%	\item BayesianOpt, Optimizacion Space:
%%%	\href{https://www.mdpi.com/2076-3417/14/6/2554}{$\gc{\bullet}$} 
%%%	particle swarm optimization
%%%	\href{https://link.springer.com/article/10.1007/s40747-023-01265-3}{$\gc{\bullet}$} 
%%%	\href{https://www.ijisae.org/index.php/IJISAE/article/view/3729}{$\gc{\bullet}$} 
%%%	\item Callbacks
%%%	\href{https://medium.com/@ompramod9921/callbacks-your-secret-weapon-in-machine-learning-a054090b828f}{$\gc{\bullet}$} 
%%%\end{itemize}
%%%
%%%Quantization techniques reducing the precision of weights and activations in a neural network to faster inference with minimal loss in accuracy. Time-series Dense Encoder
%%%\href{https://medium.com/@plthiyagu/tide-time-series-dense-encoder-ae8f5aff1a9c}{$\gc{\bullet}$}\href{https://arxiv.org/pdf/2304.08424}{$\gc{\bullet}$} 
%%%
%%%Distributed Training: and GPU Acceleration: 
%%%
%%%Batch Processing
%%%
%%%Recoding in highly efficient C++ code and Memory Management
%%%
%%%
%%%\end{list}
%\end{enumerate}
%
%\begin{figure}[!ht] 
%	\centering
%	{\resizebox{.93\columnwidth}{!}{\includegraphics{Figures/SSTechniques}}} 	
%	\caption{spectrum sensing techniques}
%\end{figure}
%
%\begin{figure}[!ht] 
%	\centering
%	{\resizebox{.54\columnwidth}{!}{\includegraphics{Figures/SSTypes}}} 	
%	\caption{Types of spectrum sensing\href{https://www.igi-global.com/pdf.aspx?tid=322771&ptid=307143&ctid=4&oa=true&isxn=9781668473665}{$\rojo{\bullet}$}}
%\end{figure}
%\clearpage\newpage
%
% 

%\clearpage\newpage 
%\section*{Concepts: CR -- SDR -- SS}
%\begin{DefQuot}{2.1}
%	{\begin{itemize}
%			\item 
%			\textit{Cognitive Radio}: intelligent processing and flow controlling of wireless communication for effective use of radio resources and to enable the coexistence between primary and secondary users (cognitive users).
%		\end{itemize}
%	}
%\end{DefQuot}
%\begin{enumerate}
%	\item Primary User (PU) is a customer of the spectrum band, having licensed access at any time in a geographical area. Multiple PUs can use the same spectrum simultaneously -- MPU user cognitive radio network.
%	\item Secondary User (SU or CR) is licensed to access bands of the spectrum when the corresponding PU or multiple PUs are not accessing them. 
%\end{enumerate}
%
%The following three features set cognitive radio apart from conventional radio:
%\begin{itemize}
%	\item
%	\textsl{Cognition}: CR is aware of its physical and administrative surroundings.
%	\item
%	\textsl{Reconfiguration}: This cognitive understanding allows CR to select whether to dynamically and independently change its parameters.
%	\item
%	\textsl{Learning}: CR can benefit from the experience and test new setups in fresh circumstances.
%\end{itemize}
%\bigskip
%\begin{DefQuot}{2.1}
%	{
%		\textit{Spectrum Sensing} is the process of understanding of the state of channel occupancy and identifying the existence of spectrum holes in a geographical area before transmission is initiated. 
%		
%		The spectrum sensing problem is defined as a hypotheses test based on the presence of the primary user signal:
%		
%		\begin{itemize}
%			\item $H_0$: No primary user signal is present (absence)
%			
%			\item $H_1$: primary user signal is present (presence)
%		\end{itemize}
%	}
%\end{DefQuot}
\begin{list}{*-}{}
	\item{First-level compression}
	\begin{align*}
		X(N_{\max};\omega),&\quad \to \widehat{_{SNR}}, \hat{\gamma}\\
		X(N_{\max},\gamma,\widehat{_{SNR}};\omega),&\quad\to \textrm{thresholding}\\	
		X_{\eta}(N^{'}_{\max},\gamma;\omega)&\quad = \operatorname{AR-model}\{X(N_{\max},\gamma,\widehat{_{SNR}};\omega) - X(N_{\max};\omega) \} \\
		X(N_{\operatorname{opt}},\widehat{_{ SNR}};\omega)&\quad = 
		X(N_{\max},\gamma,\widehat{_{SNR}};\omega) + X_{\eta}(N_{\max},\gamma;\omega)\\
		&\quad = \operatorname{compress}\{X(N_{\max},\gamma,\widehat{_{SNR}};\omega) \} +
		\operatorname{compress}\{X_{\eta}(N_{\max},\gamma;\omega)\}\\
		&\quad = [\overline{x}(\omega_n){\ge} \gamma, \omega_n: n{\in} N^{c}_{X}] + [\alpha_k:k{\in} N^{c}_{\eta}] 
		\\&\quad \to N^{c}_{X} + N^{c}_{\eta}\ll N_{\max}
	\end{align*}
	\item{Second-level compression}
\end{list}
\clearpage\newpage
\begin{align*}
	X_{\eta}(N^{'}_{\max},\gamma;\omega)&\quad = \operatorname{imputation}\{X(N_{\max},\gamma,\widehat{_{SNR}};\omega) - X(N_{\max};\omega) \} \\
	%	X_{\eta}(N_{\max},\gamma;\omega)&\quad = X(N_{\max},\gamma,\widehat{_{SNR}};\omega) - X(N_{\max};\omega) \\
	\varXi(N_{\operatorname{opt}};\omega)&\quad=
	\operatorname{downsampling}\{\varXi(N^{'};\omega) : N^{'}\to N_{\operatorname{opt}} \} 
	\\
	%	 X(N_{\min};\omega)\quad\\ 
\end{align*}
\clearpage\newpage 

\end{document}


\begin{figure}[!ht] 	
	{\resizebox{.51\columnwidth}{!}{\includegraphics{Figures/SDR}}} 	
	\caption{ Software Defined Radio}
\end{figure}

\subsection{Testbed Optimization}
ware with low precision support.

Profiler Guided Optimization: Use profilers to identify hotspots in your code and focus optimization efforts where they will have the most impact.
 
 vinos
 beylis
 https://www.facebook.com/reel/259940243768478
 alfonso xiii
 https://www.facebook.com/reel/188056137681576
 El padrino
 https://www.facebook.com/reel/1395175094422336
 nieve de vodka
 https://www.facebook.com/reel/1150172682622848
 sangrÃ­a
 https://www.facebook.com/reel/727254439505830
 tinto de verano
 https://www.facebook.com/reel/3299811303652766
 coctel pasion
 https://www.facebook.com/reel/745758000764250
 piÃ±a colada
 https://www.facebook.com/reel/1282461045766959
 
 https://medium.com/@viniciusqroz/using-keras-tuner-to-find-the-best-parameters-for-your-neural-network-model-2dc02e0a1203
 https://blog.paperspace.com/hyperparameter-optimization-with-keras-tuner/
 https://haneulkim.medium.com/hyperparameter-tuning-with-keras-tuner-full-tutorial-f8128397e857
 https://medium.com/@maslovavictoria/bayesian-hyperparameter-optimization-of-gradient-boosting-machine-6f51996ff5f1
 https://towardsdatascience.com/the-art-of-hyperparameter-tuning-in-python-c581a129d4e4
 https://medium.com/@redeaddiscolll/deep-learning-for-time-series-forecasting-of-stock-78e4abd6ae30#id_token=eyJhbGciOiJSUzI1NiIsImtpZCI6IjkzNGE1ODE2NDY4Yjk1NzAzOTUzZDE0ZTlmMTVkZjVkMDlhNDAxZTQiLCJ0eXAiOiJKV1QifQ.eyJpc3MiOiJodHRwczovL2FjY291bnRzLmdvb2dsZS5jb20iLCJhenAiOiIyMTYyOTYwMzU4MzQtazFrNnFlMDYwczJ0cDJhMmphbTRsamRjbXMwMHN0dGcuYXBwcy5nb29nbGV1c2VyY29udGVudC5jb20iLCJhdWQiOiIyMTYyOTYwMzU4MzQtazFrNnFlMDYwczJ0cDJhMmphbTRsamRjbXMwMHN0dGcuYXBwcy5nb29nbGV1c2VyY29udGVudC5jb20iLCJzdWIiOiIxMTI2MTk3MDM0MzAyODM1MzE4NjMiLCJlbWFpbCI6ImdjYXN0ZWxsOUBnbWFpbC5jb20iLCJlbWFpbF92ZXJpZmllZCI6dHJ1ZSwibmJmIjoxNzEyMzEwMDUxLCJuYW1lIjoiR2VybWFuIENhc3RlbGxhbm9zIERvbWluZ3VleiIsInBpY3R1cmUiOiJodHRwczovL2xoMy5nb29nbGV1c2VyY29udGVudC5jb20vYS9BQ2c4b2NMUGg5X21UM1RNYmZBWVd4Y2NIVElPTGRkQVpoSmR0MGY1eGpacENTYmR1QkhRMk00Qz1zOTYtYyIsImdpdmVuX25hbWUiOiJHZXJtYW4iLCJmYW1pbHlfbmFtZSI6IkNhc3RlbGxhbm9zIERvbWluZ3VleiIsImlhdCI6MTcxMjMxMDM1MSwiZXhwIjoxNzEyMzEzOTUxLCJqdGkiOiIwNjIxODZjNGQ5NDI3ZTBhMWRlZTFmMzgwYWJiY2QyZTU4NzVlOWM0In0.O_C0SI9o7yP8V7M16K7OHQspRpGsxW3LTFZ3_nVsD7kLG3iMFMVPwJkgI8-XojR8QL3LFqnlEg88j0ZPLqv_7Q6rFJ4Za5A3gYHh09Y8Mu24qBAi3ICZXgh2FE7W41WokL_CTzT02UmHDWSUzdXq14vLHRdhZcw2CCOEX6uZTsNeXK0eWeB2UkrxZmdzXpZZo-3aqEcDQ4JM7c_5InAmkDoS0-ycxMxCH4ZSLJnZWcoe0kLvDz7aieTiaHYI5mrLjJ773Xym7mzqswbhXuTAEeFxO_E2GYLng__ylPkI5JIYyV-NGbGwr0NKT-DnvTSdouFjfNzUqkbJDAvkXCt6vA
 https://medium.com/@chenycy/accelerate-your-machine-learning-skills-with-hyperparameter-tuning-00dfd27e261c
 https://towardsdatascience.com/tune-deep-neural-networks-using-bayesian-optimization-c9f6503a049f
 https://gist.github.com/GermanCM/1943a0dc1eac04f848c6fe9b16947ac4
 https://pyimagesearch.com/2021/06/07/easy-hyperparameter-tuning-with-keras-tuner-and-tensorflow/
 https://www.peterspython.com/es/blog/lstm-optimizacion-multipaso-hyperparameter-con-keras-tuner}


To visualize a 64QAM (64-Quadrature Amplitude Modulation) constellation diagram using an SDR (Software-Defined Radio), follow these steps:

1. **Setup SDR**: Ensure your SDR is connected and properly configured with software like GNU Radio, SDR# (SDRSharp), or MATLAB.
2. **Transmit/Receive Signal**: Use a signal generator or capture a 64QAM signal.
3. **Demodulation**: Configure the demodulator in your software to process the received signal.
4. **Plot Constellation**: Use the softwareâ€™s plotting tools to display the constellation diagram.

### Example:
In GNU Radio, you can use a flowgraph with blocks for signal source, QAM modulator, channel model, QAM demodulator, and a constellation sink to visualize the 64QAM constellation.

Hereâ€™s a brief example code snippet in GNU Radio Companion:

```python
# GNU Radio flowgraph snippet for 64QAM
# Blocks: Signal Source -> 64QAM Modulator -> Channel Model -> 64QAM Demodulator -> Constellation Sink

from gnuradio import gr
from gnuradio import blocks
from gnuradio import digital
from gnuradio import channels
from gnuradio import qtgui

class QAMExample(gr.top_block):

 def __init__(self):
 gr.top_block.__init__(self, "64QAM Example")

 # Parameters
 samp_rate = 32000

 # Blocks
 self.src = blocks.vector_source_b([0,1,2,3,4,5,6,7]*10, True)
 self.mod = digital.qam.qam_mod(constellation_points=64)
 self.channel = channels.channel_model(noise_voltage=0.1)
 self.demod = digital.qam.qam_demod(constellation_points=64)
 self.sink = qtgui.const_sink_c(1024, '64QAM Constellation')

 # Connections
 self.connect(self.src, self.mod, self.channel, self.demod, self.sink)

if __name__ == '__main__':
 tb = QAMExample()
 tb.start()
 tb.wait()
```

This example sets up a simple flowgraph to modulate, transmit through a channel, demodulate, and then plot the 64QAM constellation.

For further detailed implementation, you can refer to GNU Radio documentation or relevant SDR software manuals.

%\item Preliminary Design of the Laboratory Stand for Remote and Subsurface Sensing
%	\href{https://ieeexplore.ieee.org/abstract/document/10380333}{$\gc{\bullet}$}

Curl is a multiplication between the nabla and a vector function.

%%%%
SW for Diversity Reception and Signal Combining: i) Maximal Ratio Combining (MRC): This technique weights and sums the signals from multiple antennas to maximize the signal-to-noise ratio.
ii) Selection Combining: The best signal (based on a metric like signal strength) from multiple antennas is selected.

\begin{python}
	from gnuradio import gr
	from gnuradio import blocks
	from gnuradio import analog
	from gnuradio import filter
	from gnuradio import audio
	
	# Create a flow graph
	fg = gr.top_block()
	
	# Sample rate set high enough to capture the entire FM signal bandwidth (e.g., 2.048 MHz).
	sample_rate = 2.048e6 # 2.048 MHz
	
	# Signal source (e.g., from an RTL-SDR or file)
	src = blocks.file_source(gr.sizeof_gr_complex, "fm_signal.dat", False)
	
	# Throttle block to control the sample rate
	throttle = blocks.throttle(gr.sizeof_gr_complex, sample_rate, True)
	
	# Frequency translating FIR filter to shift the signal to baseband
	freq_trans = filter.freq_xlating_fir_filter_ccc(1, [1], -250e3, sample_rate)
	
	# Low-pass filter to remove high-frequency components
	lpf = filter.fir_filter_ccf(1, filter.firdes.low_pass(1, sample_rate, 100e3, 10e3))
	
	# FM demodulator
	fm_demod = analog.wfm_rcv(
	quad_rate=sample_rate,
	audio_decimation=10,)
	
	# Audio sink to play the demodulated signal
	audio_sink = audio.sink(int(sample_rate / 10), "", True)
	###### The decimation factor is chosen to a manageable level for processing
	## (e.g., reducing from 2.048 MHz to 204.8 kHz with a decimation factor of 10).
	
	# Connect the blocks
	fg.connect(src, throttle, freq_trans, lpf, fm_demod, audio_sink)
	
	# Run the flow graph
	fg.run()
\end{python}